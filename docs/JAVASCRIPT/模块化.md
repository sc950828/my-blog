1、common.js
  {模块引用(require)} {模块定义(exports)} {模块标识(module)}。 require是同步的，所以不适合客户端
  服务端模块化的方法，node.js

2、AMD客户端模块化的方案
  依赖前置
  amd不同于common.js，他的require([module], callback)方法多了个callback函数，是异步加载模块。
  实现AMD的是require.is curl.js
  
3、cmd
  依赖后置，什么时候用到就什么时候引入， 是同步的。
  define(function(require,exports,module){...});
  实现cmd的是sea.js

4、import和require倒入模块的区别
  import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案
  后者支持动态引入，也就是require(${path}/xx.js)，前者目前不支持，但是已有提案(动态路由的时候碰到了这个问题)
  前者是关键词，后者不是
  前者是编译时加载，必须放在模块顶部，在性能上会比后者好一些，后者是运行时加载，理论上来说放在哪里都可以
  前者采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。而后者在导出时是值拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入
  前者会编译成require/exports来执行

5、模块化的好处
  避免变量污染 命名冲突
  提高代码复用率
  提高了可维护性
  方便依赖关系管理

6、module.exports和exports的区别
  exports == module.exports exports的出现就是为了简化导出，我们导出的时候module.exports.xxx完全可以用exports.xxx代替
  但是我们使用module.exports = {}的时候不能用exports = {}替代，因为我们的exports是等于module.exports的，这样写相当于切断了
  exports与module.exports的联系。

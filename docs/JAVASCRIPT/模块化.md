### 1、common.js 服务端的模块化方案

模块引用(require) 模块定义(exports) 模块标识(module)。 require 是同步的，所以不适合客户端。服务端模块化的方法，例子有 node.js

### 2、AMD 客户端模块化的方案

依赖前置
amd 不同于 common.js，他的 `require([module], callback)`方法多了个 callback 函数，是异步加载模块。
实现 AMD 的是 require.is curl.js

### 3、cmd

依赖后置，什么时候用到就什么时候引入， 是同步的。`define(function(require,exports,module){...});`
实现 cmd 的是 sea.js

### 4、import 和 require 倒入模块的区别

- import 是 ES6 标准中的模块化解决方案，require 是 node 中遵循 CommonJS 规范的模块化解决方案
- require 后者支持动态引入，也就是 require(\${path}/xx.js)，import 目前不支持，但是已有提案(动态路由的时候碰到了这个问题)
- import 是关键词，require 不是
- import 是编译时加载，必须放在模块顶部，在性能上会比 require 好一些，require 是运行时加载，理论上来说放在哪里都可以
- import 采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。而 require 在导出时是值拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入。
- import 会编译成 require/exports 来执行。

### 5、模块化的好处

- 避免变量污染 命名冲突
- 提高代码复用率
- 提高了可维护性
- 方便依赖关系管理

### 6、module.exports 和 exports 的区别

exports == module.exports exports 的出现就是为了简化导出，我们导出的时候 module.exports.xxx 完全可以用 exports.xxx 代替。但是我们使用 module.exports = {}的时候不能用 exports = {}替代，因为我们的 exports 是等于 module.exports 的，这样写相当于切断了 exports 与 module.exports 的联系。exports 就只能 exports.xxx=xxx,不能 exports=xxx 直接赋值。

### 使用 FileReader 本地预览图片

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图片本地预览示例</title>
  </head>
  <body>
    <h3>阿宝哥：图片本地预览示例</h3>
    <input type="file" accept="image/*" onchange="loadFile(event)" />
    <img id="previewContainer" />

    <script>
      const loadFile = function(event) {
        const reader = new FileReader();
        reader.onload = function() {
          const output = document.querySelector("#previewContainer");
          // 把Data URL给图片对象
          output.src = reader.result;
        };
        // 调用 FileReader 对象的 readAsDataURL() 方法，把本地图片对应的 File 对象转换为 Data URL。
        reader.readAsDataURL(event.target.files[0]);
        // Data URL，它由四个部分组成：前缀（data:）、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身
        // data:[<mediatype>][;base64],<data>

        // 其实对于 FileReader 对象来说，除了支持把 File/Blob 对象转换为 Data URL 之外，它还提供了
        // readAsArrayBuffer() 和 readAsText() 方法，用于把 File/Blob 对象转换为其它的数据格式。

        reader对象;
        // error: null
        // onabort: null
        // onerror: null
        // onload: ƒ ()
        // onloadend: null
        // onloadstart: null
        // onprogress: null
        // readyState: 2
        // result: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhAAAAIwCAYAAADXrFK...
      };
    </script>
  </body>
</html>
```

### base64

Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。

标准的 base64 编码无需额外的信息，即可以进行解码，是完全可逆的。因此在涉及传输私密数据时，并不能直接使用 base64 编码，而是要使用专门的对称或非对称加密算法。

在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串：

- btoa()：该函数能够基于二进制数据 “字符串” 创建一个 base64 编码的 ASCII 字符串。
- atob()： 该函数能够解码通过 base64 编码的字符串数据。

```js
const name = "randy";
const base64 = btoa(name); // cmFuZHk=
console.log(base64);

const newName = atob(base64);
console.log(newName); // randy
```

### Object URL

Object URL 是一种伪协议，也被称为 Blob URL。它允许 Blob 或 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 URL.createObjectURL 方法来创建 Blob URL，该方法接收一个 Blob 对象，并为其创建一个唯一的 URL，其形式为 `blob:<origin>/<uuid>`，对应的示例如下：

```
blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641
```

```js
const image = document.querySelector("#previewContainer");
fetch(
  "https://avatars3.githubusercontent.com/u/28090587?s=460u=1497b5728215c1644d1756753ebb2f8b029675b3&v=4"
)
  .then((response) => response.blob()) // 把response转为blob对象
  .then((blob) => {
    const objectURL = URL.createObjectURL(blob); // 通过URL.createObjectURL方法把blob对象变为Blob URL
    image.src = objectURL;
  });

const image = document.querySelector("#previewContainer");
fetch(
  "https://avatars3.githubusercontent.com/u/28090587?s=460u=1497b5728215c1644d1756753ebb2f8b029675b3&v=4"
)
  .then((response) => response.arrayBuffer())
  .then((buffer) => {
    const blob = new Blob([buffer]);
    const objectURL = URL.createObjectURL(blob);
    image.src = objectURL;
  });
```

对于 fetch API 的 Response 对象来说，该对象除了提供 blob() 方法之外，还提供了 json()、 text() 、formData() 和 arrayBuffer() 等方法，用于把响应转换为不同的数据格式。

### Blob API

var aBlob = new Blob(blobParts, options);

blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。

options：一个可选的对象，包含以下两个属性：

- type —— 默认值为 ""，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。
- endings —— 默认值为 "transparent"，用于指定包含行结束符 \n 的字符串如何被写入。 它是以下两个值中的一个： "native"，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 "transparent"，代表会保持 blob 中保存的结束符不变。

```js
let myBlobParts = ["<html><h2>Hello Semlinker</h2></html>"]; // an array consisting of a single DOMString
let myBlob = new Blob(myBlobParts, {
  type: "text/html",
  endings: "transparent",
}); // the blob

console.log(myBlob.size + " bytes size");
// Output: 37 bytes size
console.log(myBlob.type + " is the type");
// Output: text/html is the type
```

blob 属性

- size（只读）：表示 Blob 对象中所包含数据的大小（以字节为单位）。
- type（只读）：一个字符串，表明该 Blob 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。

blob 方法

- slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。
- stream()：返回一个能读取 blob 内容的 ReadableStream。
- text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 USVString。
- arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 ArrayBuffer。

### ArrayBuffer

ArrayBuffer 对象用来表示「通用的、固定长度的」原始二进制数据缓冲区。

下面的例子创建了一个 8 字节的缓冲区，并使用一个 Int32Array 来引用它

```js
let buffer = new ArrayBuffer(8);
let view = new Int32Array(buffer);
```

### Blob vs ArrayBuffer

「ArrayBuffer」 对象用于表示通用的，固定长度的原始二进制数据缓冲区。你不能直接操纵 ArrayBuffer 的内容，而是需要创建一个类型化数组对象或 DataView 对象，该对象以特定格式表示缓冲区，并使用该对象读取和写入缓冲区的内容。

「Blob」 类型的对象表示不可变的类似文件对象的原始数据。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于 Blob，继承了 Blob 功能并将其扩展为支持用户系统上的文件。

区别

除非你需要使用 ArrayBuffer 提供的写入/编辑的能力，否则 Blob 格式可能是最好的。

Blob 对象是不可变的，而 ArrayBuffer 是可以通过 TypedArrays 或 DataView 来操作。

虽然 Blob 可以直接作为参数传递给其他函数，比如 window.URL.createObjectURL()。但是，你可能仍需要 FileReader 之类的 File API 才能与 Blob 一起使用。

使用 FileReader 的 readAsArrayBuffer() 方法，可以把 Blob 对象转换为 ArrayBuffer 对象；

使用 Blob 构造函数，如 new Blob([new Uint8Array(data)]);，可以把 ArrayBuffer 对象转换为 Blob 对象。

### DataView

DataView 视图是一个可以从二进制 ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。

```js
new DataView(buffer [, byteOffset [, byteLength]])
```

buffer：一个已经存在的 ArrayBuffer 或 SharedArrayBuffer 对象，DataView 对象的数据源。

byteOffset（可选）：此 DataView 对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。

byteLength：此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。

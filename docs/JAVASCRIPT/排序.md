### 1、冒泡排序

```js
// 从后往前两两比较,两两交换位置,较小的冒泡到前面来，比较的次数越来越少
// 两个数比较大小，较大的数下沉，较小的数冒起来。
for (let i = 0; i < arr.length - 1; i++) {
  //循环arr.length-1次
  for (let j = arr.length - 1; j > i; j--) {
    //循环次数越来越少
    if (arr[j] < arr[j - 1]) {
      const tmp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = tmp;
    }
  }
}
```

### 2、选择排序

```js
// 从前往后一个数与所有的数比较，与最小的数交换位置
// 在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；(第一个元素与后面的n-1个数一一相比较)
// 第二次遍历n-2个数，找到最小的数值与第二个元素交换；(第二个元素与后面的n-2个元素一一比较)
// 第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。(比较的次数越来越少)
for (let i = 0; i < arr.lenght - 1; i++) {
  //外层选择一个元素
  let minIndex = i;
  for (let j = i + 1; j < arr.length; j++) {
    //外层的一个元素与内层的元素一一比较
    if (arr[j] < arr[minIndex]) {
      minIndex = j;
    }
  }
  if (minIndex != i) {
    const tmp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = tmp;
  }
}
```

### 3、插入排序

```js
// 从后往前两两比较，比较的越来越多
//假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。
for (let i = 0; i < caruArr.length - 1; i++) {
  for (let j = i + 1; j > 0; j--) {
    if (caruArr[j] < caruArr[j - 1]) {
      const tmp = caruArr[j];
      caruArr[j] = caruArr[j - 1];
      caruArr[j - 1] = tmp;
    }
  }
}
```

### 4、sort()方法

- 会修改原数组
- 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。第一个相同比较第二个。
- 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个参数 a 和 b，a 和 b 代表数组中的项，然后返回一个用于说明这两个值的相对顺序的数字。适用与数字。
  - return a-b 升序即 a > b
  - return b-a 降序 a < b
- 如果是对象上的某个属性比较，可以使用下面的比较。使用与字符串。升序
  - if(a.xxx > b.xxx){return 1} //1升序。降序的话返回-1
  - if(a.xxx < b.xxx>){return -1}
  - else return 0

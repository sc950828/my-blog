### 1、原型继承

    f.prototype = {}或者使用Object.create(原型，新属性)
    优点
      父类的属性方法和原型链上的属性方法都能被继承
    缺点
      不能给父类构造器传参，所有实例原型都相同
      一个实例修改原型上的方法或者父类的属性，所有的实例的原型方法或实例属性都会变。
      只能继承一个

### 2、构造继承

    优点
      能传参给父构造器
      一个实例修改属性不会影响其他实例
      可以继承多个构造函数属性（call多个构造函数）
    缺点
      不能继承父类原型链上的属性和方法
      instanceof不是父类的实例

### 3、组合继承

    优点
      结合了两种模式的优点，能传参和能调用父原型链上的属性方法
      一个实例改动其他实例不收影响
    缺点
      调用了两次父类构造函

### 4、JavaScript 继承的几种实现方式？

- （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例
  对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

- （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方
  法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的
  方法子类型也没有办法访问到。

- （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实
  现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单
  独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类
  型的原型中多了很多不必要的属性。

- （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入
  一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个
  对象实现一种简单继承，ES5 中定义的 Object.create(原型，新属性) 方法就是原型式继承的实现。缺点与原型链方式相同。

- （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个
  对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对
  一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

- （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属
  性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

### 5、寄生式组合继承的实现？

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function() {
  console.log("My name is " + this.name + ".");
};

function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.sayMyGrade = function() {
  console.log("My grade is " + this.grade + ".");
};
```

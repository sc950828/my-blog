### 数组扁平化

数组扁平化是指将一个多维数组变为一维数组

```js
// 1、使用toString()和split()方法
let arr1 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, { name: "randy" }]
];
// 这种方法适用于数字比较好
const newArr1 = arr1.toString().split(",");
console.log(newArr1);

// 2、使用reduce
let arr2 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, { name: "randy" }]
];
// reduce
function flatten(arr) {
  return arr.reduce((initialValue, currentValue) => {
    return initialValue.concat(
      Array.isArray(currentValue) ? flatten(currentValue) : currentValue
    );
  }, []);
}
console.log(flatten(arr2));

// 3、使用join()和split()方法
let arr3 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, { name: "randy" }]
];
// 这种方法适用于数字比较好
const newArr3 = arr3.join(",").split(",");
console.log(newArr3);

// 4、递归
let arr4 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, { name: "randy" }]
];
function flatten2(arr) {
  let newArr = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      newArr = newArr.concat(flatten2(item));
    } else {
      newArr.push(item);
    }
  });
  return newArr;
}
console.log(flatten2(arr4));

// 5、扩展运算符和contact
let arr5 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, { name: "randy" }]
];
console.log([].concat(...arr5));
```

### 比较两数组差异

```js
const arr1 = [1, 2, 3];
const arr2 = [3, 4, 5];
// 第一种方法
function diff1(arr1, arr2) {
  function getDiff(arr1, arr2) {
    const diff = [];
    arr1.forEach(element => {
      if (!arr2.includes(element)) {
        diff.push(element);
      }
    });
    return diff;
  }

  return getDiff(arr1, arr2).concat(getDiff(arr2, arr1));
}
console.log(diff1(arr1, arr2));

// 第二种方法
function diff2(arr1, arr2) {
  return arr1
    .filter(item => !arr2.includes(item))
    .concat(arr2.filter(item => !arr1.includes(item)));
}
console.log(diff2(arr1, arr2));

// 第三种方法
function diff3(arr1, arr2) {
  return arr1
    .concat(arr2)
    .filter(item => !arr1.includes(item) || !arr2.includes(item));
}
console.log(diff3(arr1, arr2));
```

### 数组随机排序

```js
// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。

function randomSort(a, b) {
  return Math.random() > 0.5 ? -1 : 1;
}

// 缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。

// （2）随机从原数组抽取一个元素，加入到新数组

function randomSort(arr) {
  var result = [];

  while (arr.length > 0) {
    var randomIndex = Math.floor(Math.random() * arr.length);
    result.push(arr[randomIndex]);
    arr.splice(randomIndex, 1);
  }

  return result;
}

// （3）随机交换数组内的元素（洗牌算法类似）

function randomSort(arr) {
  var index,
    randomIndex,
    temp,
    len = arr.length;

  for (index = 0; index < len; index++) {
    randomIndex = Math.floor(Math.random() * (len - index)) + index;

    temp = arr[index];
    arr[index] = arr[randomIndex];
    arr[randomIndex] = temp;
  }

  return arr;
}

// es6
function randomSort(array) {
  let length = array.length;

  if (!Array.isArray(array) || length <= 1) return;

  for (let index = 0; index < length - 1; index++) {
    let randomIndex = Math.floor(Math.random() * (length - index)) + index;

    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];
  }

  return array;
}
```

### 类数组变数组

```js
// 类数组没有数组的方法
// console.log(document.all.pop());

// 变数组
// slice
const arr1 = Array.prototype.slice.call(document.all);
console.log(arr1, arr1 instanceof Array);

// 深拷贝一下 因为会改变原数组
let likeArr = Array.from(document.all);
// splice
const arr2 = Array.prototype.splice.call(likeArr, 0);
console.log(arr2, arr2 instanceof Array);

// concat 使用apply调用
const arr3 = Array.prototype.concat.apply([], document.all);
console.log(arr3, arr3 instanceof Array);

// from
const arr4 = Array.from(document.all);
console.log(arr4, arr4 instanceof Array);
```

### 数组去重

```js
// 有includes indexOf lastIndexOf find findIndex Set等方法
const arr = [1, 2, 3, 5, 6, 5, 3, 0, 0];
const newArr1 = [];
// 使用includes或者find indexOf判断
for (const iterator of arr) {
  if (!newArr1.includes(iterator)) {
    newArr1.push(iterator);
  }
}
console.log(newArr1);

const newArr2 = [];
for (const iterator of arr) {
  if (newArr2.indexOf(iterator) === -1) {
    newArr2.push(iterator);
  }
}
console.log(newArr2);

const newArr3 = [];
for (const iterator of arr) {
  if (newArr3.lastIndexOf(iterator) === -1) {
    newArr3.push(iterator);
  }
}
console.log(newArr3);

const newArr4 = [];
for (const iterator of arr) {
  if (typeof newArr4.find(i => i === iterator) === "undefined") {
    newArr4.push(iterator);
  }
}
console.log(newArr4);

const newArr5 = [];
for (const iterator of arr) {
  if (newArr5.findIndex(i => i === iterator) === -1) {
    newArr5.push(iterator);
  }
}
console.log(newArr5);

const newArr6 = [...new Set(arr)];
console.log(newArr6);
```

### call apply bind

    apply 参数列表是一个数组，call 和 bind 是参数列表。
    bind 需要再次调用。

    call 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。

    （3）处理传入的参数，截取第一个参数后的所有参数。

    （4）将函数作为上下文对象的一个属性。

    （5）使用上下文对象来调用这个方法，并保存返回结果。

    （6）删除刚才新增的属性。

    （7）返回结果。


    apply 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。

    （3）将函数作为上下文对象的一个属性。

    （4）判断参数值是否传入

    （4）使用上下文对象来调用这个方法，并保存返回结果。

    （5）删除刚才新增的属性

    （6）返回结果


    bind 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）保存当前函数的引用，获取其余传入参数值。

    （3）创建一个函数返回

    （4）函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

```js
// call
function myCall(context) {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }
  let args = arguments.slice(1);
  let result = null;

  context = context || window;
  context.fn = this;

  result = context.fn(...args);

  delete context.fn;

  return result;
}

// apply
function myApply() {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }

  let result = null;

  context = context || window;
  context.fn = this;

  if (argumenus[1]) {
    result = context.fn(...argumenus[1]);
  } else {
    result = context.fn();
  }

  delete context.fn;

  return result;
}

// bind
function myBind(context) {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }

  let result = null;
  let args = arguments.slice(1);

  fn = this;

  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
}
```

### instanceof

```js
function myInstanceof(l, r) {
  let L = l.__proto__;
  let R = r.prototype;
  while (true) {
    if (L === R) {
      return true;
    }
    if (L === null || L === "undefined") {
      return false;
    }
    L = L.__proto__;
  }
}
```

### 使用 new 操作符发生了什么？

创建一个空对象；
该空对象的原型指向构造函数（链接原型）：将构造函数的 prototype 赋值给对象的 `__proto__`属性；
绑定 this：将对象作为构造函数的 this 传进去，并执行该构造函数；
返回新对象：如果构造函数返回的是一个对象，则返回该对象；否则（若没有返回值或者返回基本类型），返回第一步中新创建的对象；

```js
// 模拟new
function myFactory() {
  // 创建一个空对象
  let obj = {};
  // 取出第一个参数 构造函数
  let Cons = [].shift.call(arguments);
  // 使空对象的__proto__指向构造函数的prototype
  obj.__proto__ = Cons.prototype;
  // 绑定 this：将对象作为构造函数的 this 传进去，并执行该构造函数；
  let result = Cons.apply(obj, arguments);

  // 这里用typeof result == 'object' 进行判断会有个问题：当构造函数返回 null 时，会有误差，因为 typeof null == 'object'
  // 应该是除了构造函数返回一个对象，其他的都返回新创建的对象
  return Object.prototype.toString.call(result) === "[object Object]"
    ? result
    : obj;
}

// 测试一下
function Angel(name, age) {
  this.strength = 60;
  this.age = age;
  return null;
}

var person = objFactory(Angel, "randy", "24");
console.log(person.name, person.habit); // undefined undefined
console.log(person.strength, person.age); // 60 "18"
```

### 如何封装一个 javascript 的类型判断函数？

```js
function getType(value) {
  // 判断数据是 null 的情况
  if (value === null) {
    return value + "";
  }

  // 判断数据是引用类型的情况
  if (typeof value === "object") {
    // 可以判断具体的对象类型，包括正则等，但是无法判断自定义对象类型。
    // 内置对象的类型能判断出来 但是普通对象一直返回object 还需要使用instanceof判断
    // p1.constructor.name = People 我们也可以通过对象的constructor.name获取到数据类型
    let valueClass = Object.prototype.toString.call(value),
      type = valueClass.split(" ")[1].split("");

    type.pop();

    return type.join("").toLowerCase();
  } else {
    // 判断数据是基本数据类型的情况和函数的情况
    return typeof value;
  }
}
```

### 如何判断一个对象是否为空对象？

```js
function checkNullObj(obj) {
  return Object.keys(obj).length === 0;
}
```

### 如何查找一篇英文文章中出现频率最高的单词？

```js
function findMostWord(article) {
  // 合法性判断
  if (!article) return;

  const aticle = "hello ，what you name。my name is randy，nice to meet you！";
  // 把单词提取出来
  const aticleArr = aticle.toLowerCase().match(/[a-z]+/g);
  // 把字母提取出
  // const aticleArr = aticle.toLowerCase().match(/[a-z]/g)
  let maxNum = 0;
  let maxWord = "";
  let tempArr = [];
  // 循环单词数组
  aticleArr.forEach(word => {
    if (!tempArr.includes(word)) {
      tempArr.push(word);
      // 单词在文章中出现的次数
      let len = aticle.toLowerCase().match(new RegExp(word, "g")).length;
      if (len > maxNum) {
        maxNum = len;
        maxWord = word;
      }
    }
  });
  console.log(maxWord, maxNum);
}
```

### 如何让 (a == 1 && a == 2 && a == 3) 的值为 true？

```js
// 利用闭包 重写[Symbol.toPrimitive]方法
const a = {
  [Symbol.toPrimitive]: (function () {
    let i = 1;
    return function () {
      return i++;
    };
  })()
};
console.log(a == 1 && a == 2 && a == 3);

// 利用代理
const b = new Proxy(
  {},
  {
    i: 1,
    get: function () {
      return () => this.i++;
    }
  }
);
console.log(b == 1 && b == 2 && b == 3);

// 利用类型转换
const c = [1, 2, 3];
c.toString = function () {
  console.log("toString");
};
c.valueOf = function () {
  console.log("valueOf");
};

c.valueOf = c.shift;
// 这里其实还可以重写toString方法。
console.log(c == 1 && c == 2 && c == 3);
```

### 写一个通用的事件侦听器函数。

```js
const EventUtils = {
  // 视能力分别使用dom0||dom2||IE方式 来绑定事件
  // 添加事件
  addEvent: function (element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },

  // 移除事件
  removeEvent: function (element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  },

  // 获取事件目标
  getTarget: function (event) {
    return event.target || event.srcElement;
  },

  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
  getEvent: function (event) {
    return event || window.event;
  },

  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },

  // 取消事件的默认行为
  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  }
};
```

### 实现 EventEmitter

```js
class EventEmitter {
  constructor() {
    // handlers是一个map，用于存储事件与回调之间的对应关系
    this.handlers = {};
  }

  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数
  on(eventName, cb) {
    // 先检查一下目标事件名有没有对应的监听函数队列
    if (!this.handlers[eventName]) {
      // 如果没有，那么首先初始化一个监听函数队列
      this.handlers[eventName] = [];
    }

    // 把回调函数推入目标事件的监听函数队列里去
    this.handlers[eventName].push(cb);
  }

  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数
  emit(eventName, ...args) {
    // 检查目标事件是否有监听函数队列
    if (this.handlers[eventName]) {
      // 如果有，则逐个调用队列里的回调函数
      this.handlers[eventName].forEach(callback => {
        callback(...args);
      });
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, cb) {
    const callbacks = this.handlers[eventName];
    const index = callbacks.indexOf(cb);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  }

  // 为事件注册单次监听器
  once(eventName, cb) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const wrapper = (...args) => {
      cb.apply(...args);
      this.off(eventName, wrapper);
    };
    this.on(eventName, wrapper);
  }
}
```

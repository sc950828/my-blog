### 1、观察者模式

Subject 直接通知 Observers。 大多同步。

```js
var events = (function() {
  var topics = {};

  return {
    // 注册监听函数
    subscribe: function(topic, handler) {
      if (!topics.hasOwnProperty(topic)) {
        topics[topic] = [];
      }
      topics[topic].push(handler);
    },

    // 发布事件，触发观察者回调事件
    publish: function(topic, info) {
      if (topics.hasOwnProperty(topic)) {
        topics[topic].forEach(function(handler) {
          handler(info);
        });
      }
    },

    // 移除主题的一个观察者的回调事件
    remove: function(topic, handler) {
      if (!topics.hasOwnProperty(topic)) return;

      var handlerIndex = -1;
      topics[topic].forEach(function(item, index) {
        if (item === handler) {
          handlerIndex = index;
        }
      });

      if (handlerIndex >= 0) {
        topics[topic].splice(handlerIndex, 1);
      }
    },

    // 移除主题的所有观察者的回调事件
    removeAll: function(topic) {
      if (topics.hasOwnProperty(topic)) {
        topics[topic] = [];
      }
    }
  };
})();
```

### 2、发布-订阅模式

- 发布者和订阅者不知道对方的存在。需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息。
- 换句话说，发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在。大多异步。

### 3、单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点

```js
// 保证一个类仅有一个实例，并提供一个访问它的全局访问点
function Manager(name) {
  this.name = name;
  this.getName = function() {
    return this.name;
  };
}

// 使用到了闭包
const singleModel = (function() {
  let manager = null;
  return function(name) {
    if (!manager) {
      manager = new Manager(name);
    }
    return manager;
  };
})();

console.log("singleModel('randy')", singleModel("randy"));
console.log("singleModel('randy').getName()", singleModel("randy").getName()); // randy
console.log("singleModel('demi').getName()", singleModel("demi").getName()); // randy
```

### 4、策略模式

将算法的使用和算法的实现分离开来。

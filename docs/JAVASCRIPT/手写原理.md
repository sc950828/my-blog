### call apply bind

    apply 参数列表是一个数组，call 和 bind 是参数列表。
    bind 需要再次调用。

    call 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。

    （3）处理传入的参数，截取第一个参数后的所有参数。

    （4）将函数作为上下文对象的一个属性。

    （5）使用上下文对象来调用这个方法，并保存返回结果。

    （6）删除刚才新增的属性。

    （7）返回结果。


    apply 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。

    （3）将函数作为上下文对象的一个属性。

    （4）判断参数值是否传入

    （4）使用上下文对象来调用这个方法，并保存返回结果。

    （5）删除刚才新增的属性

    （6）返回结果


    bind 函数的实现步骤：

    （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。

    （2）保存当前函数的引用，获取其余传入参数值。

    （3）创建一个函数返回

    （4）函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

```js
// call
function myCall(context) {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }
  let args = arguments.slice(1);
  let result = null;

  context = context || window;
  context.fn = this;

  result = context.fn(...args);

  delete context.fn;

  return result;
}

// apply
function myApply() {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }

  let result = null;

  context = context || window;
  context.fn = this;

  if (argumenus[1]) {
    result = context.fn(...argumenus[1]);
  } else {
    result = context.fn();
  }

  delete context.fn;

  return result;
}

// bind
function myBind(context) {
  if (typeof this !== "function") {
    throw new TypeError("type error");
  }

  let result = null;
  let args = arguments.slice(1);

  fn = this;

  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
}
```

### instanceof

```js
function myInstanceof(l, r) {
  let L = l.__proto__;
  let R = r.prototype;
  while (true) {
    if (L === R) {
      return true;
    }
    if (L === null || L === "undefined") {
      return false;
    }
    L = L.__proto__;
  }
}
```

### 使用 new 操作符发生了什么？

创建一个空对象；
该空对象的原型指向构造函数（链接原型）：将构造函数的 prototype 赋值给对象的 `__proto__`属性；
绑定 this：将对象作为构造函数的 this 传进去，并执行该构造函数；
返回新对象：如果构造函数返回的是一个对象，则返回该对象；否则（若没有返回值或者返回基本类型），返回第一步中新创建的对象；

```js
// 模拟new
function myFactory() {
  // 创建一个空对象
  let obj = {};
  // 取出第一个参数 构造函数
  let Cons = [].shift.call(arguments);
  // 使空对象的__proto__指向构造函数的prototype
  obj.__proto__ = Cons.prototype;
  // 绑定 this：将对象作为构造函数的 this 传进去，并执行该构造函数；
  let result = Cons.apply(obj, arguments);

  // 这里用typeof result == 'object' 进行判断会有个问题：当构造函数返回 null 时，会有误差，因为 typeof null == 'object'
  // 应该是除了构造函数返回一个对象，其他的都返回新创建的对象
  return Object.prototype.toString.call(result) === "[object Object]"
    ? result
    : obj;
}

// 测试一下
function Angel(name, age) {
  this.strength = 60;
  this.age = age;
  return null;
}

var person = objFactory(Angel, "randy", "24");
console.log(person.name, person.habit); // undefined undefined
console.log(person.strength, person.age); // 60 "18"
```

### 如何封装一个 javascript 的类型判断函数？

```js
function getType(value) {
  // 判断数据是 null 的情况
  if (value === null) {
    return value + "";
  }

  // 判断数据是引用类型的情况
  if (typeof value === "object") {
    // 可以判断具体的对象类型，包括正则等，但是无法判断自定义对象类型。
    // 内置对象的类型能判断出来 但是普通对象一直返回object 还需要使用instanceof判断
    // p1.constructor.name = People 我们也可以通过对象的constructor.name获取到数据类型
    let valueClass = Object.prototype.toString.call(value),
      type = valueClass.split(" ")[1].split("");

    type.pop();

    return type.join("").toLowerCase();
  } else {
    // 判断数据是基本数据类型的情况和函数的情况
    return typeof value;
  }
}
```

### 如何判断一个对象是否为空对象？

```js
function checkNullObj(obj) {
  return Object.keys(obj).length === 0;
}
```

### 一道常被人轻视的前端 JS 面试题

```js
function Foo() {
  getName = function () {
    alert(1);
  };
  return this;
}
Foo.getName = function () {
  alert(2);
};
Foo.prototype.getName = function () {
  alert(3);
};
var getName = function () {
  alert(4);
};
function getName() {
  alert(5);
}

//请写出以下输出结果：
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```

### js for 循环注意点

```js
for (var i = 0, j = 0; i < 5, j < 9; i++, j++) {
  console.log(i, j);
}
// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。
// 当判断语句为空时，循环会一直进行。
```

### 为什么使用 setTimeout 实现 setInterval？怎么模拟？

setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。

针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。

```js
function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true
  };

  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }

  // 启动定时器
  setTimeout(interval, timeout);

  // 返回控制器
  return timer;
}
```

### js 中倒计时的纠偏实现？

在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。

一般解决倒计时中的误差的有这样两种办法：

（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。

（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。

### 如何查找一篇英文文章中出现频率最高的单词？

```js
function findMostWord(article) {
  // 合法性判断
  if (!article) return;

  const aticle = "hello ，what you name。my name is randy，nice to meet you！";
  // 把单词提取出来
  const aticleArr = aticle.toLowerCase().match(/[a-z]+/g);
  // 把字母提取出
  // const aticleArr = aticle.toLowerCase().match(/[a-z]/g)
  let maxNum = 0;
  let maxWord = "";
  let tempArr = [];
  // 循环单词数组
  aticleArr.forEach(word => {
    if (!tempArr.includes(word)) {
      tempArr.push(word);
      // 单词在文章中出现的次数
      let len = aticle.toLowerCase().match(new RegExp(word, "g")).length;
      if (len > maxNum) {
        maxNum = len;
        maxWord = word;
      }
    }
  });
  console.log(maxWord, maxNum);
}
```

### 如下输出什么？

```js
let array = [,1,,2,,3];
array = array.map((i) => ++i)
// forEach，filter，every，some会跳过空位，map会跳过空位，但是会保留这个值。
[,2,,3,,4]
```

### 统计网页中出现的标签数

```js
new Set([...document.querySelectorAll("*")].map(ele => ele.tagName)).size;
```

### 如何让 (a == 1 && a == 2 && a == 3) 的值为 true？

```js
// 利用闭包 重写[Symbol.toPrimitive]方法
const a = {
  [Symbol.toPrimitive]: (function () {
    let i = 1;
    return function () {
      return i++;
    };
  })()
};
console.log(a == 1 && a == 2 && a == 3);

// 利用代理
const b = new Proxy(
  {},
  {
    i: 1,
    get: function () {
      return () => this.i++;
    }
  }
);
console.log(b == 1 && b == 2 && b == 3);

// 利用类型转换
const c = [1, 2, 3];
c.toString = function () {
  console.log("toString");
};
c.valueOf = function () {
  console.log("valueOf");
};

c.valueOf = c.shift;
// 这里其实还可以重写toString方法。
console.log(c == 1 && c == 2 && c == 3);
```

### 什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是 1,2,3 之和。

```js
function sum(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}
console.log(sum(1)(2)(3)); // 6
```

### 下面输出什么

```js
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
  }

  constructor({ newColor = "green" } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: "purple" });
freddie.newColor == "purple";
freddie.colorChange("orange"); //静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。所以抛出 TypeError 错误
```

### 下面会输出什么

```js
let greeting;
greetign = {};
console.log(greetign); //输出{} 这个对象没被申明 默认到 window 上 全局变量。
```

### 写一个通用的事件侦听器函数。

```js
const EventUtils = {
  // 视能力分别使用dom0||dom2||IE方式 来绑定事件
  // 添加事件
  addEvent: function (element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },

  // 移除事件
  removeEvent: function (element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  },

  // 获取事件目标
  getTarget: function (event) {
    return event.target || event.srcElement;
  },

  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
  getEvent: function (event) {
    return event || window.event;
  },

  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },

  // 取消事件的默认行为
  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  }
};
```

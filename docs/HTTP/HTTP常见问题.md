### 1、http 有哪些方法，分别有什么作用？

    http1.0
      get  获取数据
      post 新增数据
      head 获取响应头，使用场景是请求可能是大文件的时候，先发送head请求判断资源大小是否能下载。
    http1.1
      put  更新 全部更新
      patch 更新，部分更新
      delete 删除
      options 询问，获取目的资源所支持的通信选项。非简单请求在跨域的时候会发送该请求。
      trace 回显服务器收到的请求，主要用于测试或诊断
      connect HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器

### 2、get post 区别？

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，中文会被转码，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示多次执行相同的操作，结果也是相同的)
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

### 3、get post 请求参数长度问题

- 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:
  - 1、HTTP 协议 未规定 GET 和 POST 的长度限制
  - 2、GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度
  - 3、不同的浏览器和 WEB 服务器，限制的最大长度不一样
  - 4、要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

### 4、PUT 和 POST 都是给服务器发送新增资源，有什么区别？

PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而 POST 方法是非幂等的。多次调用会生成多个

### 5、PUT 和 PATCH 都是给服务器发送修改资源，有什么区别？

PUT 和 PATCH 都是更新资源，PUT 是全部更新，而 PATCH 用来对已知资源进行局部更新。修改什么传什么。

### 6、请简单介绍一下 LRU （Least recently used）算法

- LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。
- 核心思想
  - 新数据插入到链表头部；
  - 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
  - 当链表满的时候，将链表尾部的数据丢弃。

### 7、http 是无状态的协议这个通过什么解决了？

- 解决这个问题使用到了 cookie
- 服务端生成 cookie 通过响应头部字段`<Set-Cookie: >`把数据传送给客户端
- 客户端通过请求头部字段 Cookie 把数据传送给服务端

### 8、http 和 https 异同？

- http
  - http 使用明文 内容可能会被窃听
  - http 不验证通信方的身份 可能会被伪装
  - http 无法证明报文的完整性 可能会被篡改
  - http 端口是 80
  - http 与 tcp 进行通信，而 https 与 ssl 或者 tls 层通信
- https
  - https 端口是 443
  - https 多了证书这一概念
  - https 不是新的协议 是身披 ssl/tls 协议外壳的 http
  - HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。
  - https 采用公开密钥加密和共享密钥加密两者并用的加密方式
- 什么是 tls/ssl
  - 通俗的讲，TLS、SSL 其实是类似的东西，SSL 是个加密套件，负责对 HTTP 的数据进行加密。TLS 是 SSL 的升级版。现在提到 HTTPS，加密套件基本指的是 TLS。

### 9、UDP TCP 异同？

    UDP 类似发短信
      无连接 不需要连接直接传输
      不可靠 不管对方是否已经收到 没有流量控制 没有拥塞控制
      面向报文
      高效 不连接不要要握手所以速度快，一般用于及时通讯 如qq
      UDP 可以一对一或者一对多或者多对一或者多对多
      UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短
      适合直播、视频、语音、会议等实时性要求高的
    TCP
      有连接 三次握手四次挥手
      可靠传输 提供流量控制 拥塞控制等 确认应答机制
      面向字节流
      效率较udp低
      tcp只能一对一
      首部二十多个字节 开销较UDP大
      适用于要求可靠传输的应用 例如文件传输

### 10、http1 http1.1 http2 http3 都有啥特点？

- http1
  - 每次发送请求的时候，都需要进行一次 TCP 的连接
  - 一个请求必须在前一个请求响应到达之前才能发送，会导致阻塞
- http1.1
  - 为解决 http1 一次连接处理一个请求的问题，http1.1 使用了持久连接，http1.1 默认所有的连接都是持久连接 Connection: keep-alive。这样客户端发起多个 HTTP 请求时就减少了 TCP 握手造成的网络资源和通信时间的浪费
    但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）
  - HTTP/1.1 允许范围请求，即在请求头中加入 Range 头部
  - HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部
  - 新增了 cache-control 头部字段
  - 浏览器上看到的并行请求是开启了多个 tcp 连接(6-8 个)，http1.1 一个连接里面并不支持并行请求。
- http2
  - 所有的 HTTP2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。实现了真正意义上的并行请求。在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输并发所有的请求数据。更快更高效一个 tcp 链接并发多个请求(通过帧和流)帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流，代表一个请求。每个帧都有唯一的标识。
  - 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP1.1 旧版本中的队头阻塞问题，极大的提高传输性能。
  - 二级制传输 由以前的文本传输改为二进制传输。头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
  - 头部压缩 一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引 号，这样就能提高速度了。
  - 在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。
  - 缺点
    - 因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。
    - 我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传 输数据。所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2%的丢包率 时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。
- http3
- http3 底层不再使用 tcp 协议 而是使用全新的基于 UDP 的 QUIC 协议。解决 http2 丢包的问题。QUIC 基于 UDP 实现，但在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。

### 11、https 工作原理是什么？这也是 https 如何保证安全传输的？

- 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
- 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
- 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
- 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
- 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来对称加密信息。

什么是数字证书？

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

验证证书的有效性

- 服务器把证书发送过来，证书上有一些基本信息和一个签名，签名的内容是指纹算法和指纹，指纹内容是基本信息通过指纹算法计算出来的 hash 值。签名是证书机构通过私钥加密的。
- 客户端寻找内置证书，判断服务器发来的证书是否在自己内置的证书列表，找到了就使用内置证书的公钥解密签名得到指纹和指纹算法，然后使用指纹算法计算内容的 hash，拿这两个 hash 对比判断是否一致，一致就通过。

总结

- 所以说 https 是使用了非对称加密和对称加密相结合的方式。
- https 并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，通过非对称加密的方式生成私有秘钥，最后通过该秘钥对称加密传输数据。
- 还有验证证书的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。

- 实现原理

  - TLS 的握手过程主要用到了三个方法来保证传输的安全。

  - 首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

  - 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

  - 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。

  - 但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

  - 为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最重要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。

### 12、http 三次握手 四次挥手都干了些啥？

    三次握手
      客户端发送带syn标志的包seq=x。 Client进入SYN-SENT状态
      服务端收到包然后发送带syn标志的包和ack包 seq=y ack=x+1。 Server进入SYN-RECEIVED状态
      客户端收到服务端的包然后再发送带ack标志的包 ack=y+1。 Client进入ESTABLISHED状态，Server进入ESTABLISHED状态
    四次挥手
      客户端发送带fin标志的包 fin=m，进入FIN-WAIT1状态
      服务端收到fin包然后再发送带ack标志的包 ack=m+1，进入CLOSE_WAIT状态。服务端仍然可以发送数据。
      服务端发送带fin标志的包 fin=n，服务端进入LAST-ACK状态
      客户端收到服务端发送的的fin包，发送ack包 ack=n+1。客户端进入TIME-WAIT状态。该状态会持续 2MSL。
      若2MSL时间段内没有 服务端的重发请求的话，就进入 CLOSED 状态，当服务端收到确认应答后，也便进入 CLOSED 状态

### 13、为什么是三次握手？

为了防止出现请求超时导致脏连接。为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

当客户端发出第一个连接请求报文段时并没有丢失，而是在某个网络节点出现了长时间的滞留，以至于延误了连接请求在某个时间之后才到达服务器。这应该是一个早已失效的报文段。但是服务器在收到此失效的连接请求报文段后，以为是客户端的一个新请求，于是就向客户端发出了确认报文段，同意建立连接，然而客户端状态早已不是 SYl_SENT 状态，所以并不会传输数据。假设不采用三次握手，那么只要服务器发出确认后，新的连接就可以建立了。但是由于客户端没有发出建立连接的请求，因此不会管服务器的确认，也不会向服务器发送数据，但服务器却以为新的运输连接已经建立，一直在等待，所以，服务器的资源就白白浪费掉了。

### 14、为什么是四次挥手？

为了保证在最后断开的时候，客户端能够发送最后一个 ACK 报文段能够被服务器接收到。如果服务器没收到就不会进入 close 状态，会一直在 CLOSE_WAIT。 客户端最后表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 Close 状态，而无须经过 CLOSE_WAIT 状态。

### 15、为何客户端最后还等待 2MSL

为了保证最后发送的 ack 包能被服务器接收到，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

### 16、Etag 是由什么生成的，与另外一种协商缓存的区别是什么?

- Etag 是由 Last-Modified 与 Content-Length 计算而成，etag 与 If-None-Match 一起搭配组成协商缓存，这种协商缓存是下面这种协商缓存的升级版，检测时间的同时还检测文件大小，所以更准确。
- 另外一种协商缓存是 Last-Modified 与 If-Modified-Since 搭配组成的协商缓存，这种缓存只根据时间来计算，所以相对不准确，只能应用于秒级别的修改，如果在一秒内修改，检测不到。

### 17、如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改？

不一定，因为编辑了文件但是并未修改内容时 Last-Modified 的时间也会发生变化，所以 Etag 会重新生成。

### 18、http 服务中静态文件的 Last-Modified 是根据什么生成的？

更新时间

### 19、SSL 连接断开后如何恢复？

一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

### 20、当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？

（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。(浏览器缓存 操作系统缓存 路由缓存)

（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地
址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用
户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）最后一步是 TCP 断开连接的四次挥手过程。

### 21、负载平衡的两种实现方式？

一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。

另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。

### 22、即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？

短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。

短轮询的基本思路就是浏览器每隔一段时间向服务器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。

长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

SSE(html5 新增) 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。

上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。

### 23、怎么实现多个网站之间共享登录状态

在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该 token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。

### 24、光纤宽带上网是以什么样的形式传输数据呢？

首先计算机网卡传输出来的数据是电信号，光纤传输的是光脉冲信号，有光脉冲表示 1，无光脉冲表示 0。
而可见光的频率大约是 10 的 8 次方 MHz，因此光纤通信系统的带宽远远大于其它各种传输媒体的带宽
所以我们计算机传输数据需要先把电信号转为光信号，然后光信号快到服务器的时候，再把光信号转为电信号。

### 25、如果说在头部中间故意加一个空行会怎么样？

那么空行后的内容全部被视为实体。

### 26、对于定长和不定长的数据，HTTP 是怎么传输的？

- 对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。
- 对于不定长包体而言是如何传输我们需要使用 Transfer-Encoding: chunked。这个头部字段表示分块传输数据，设置这个字段后会自动产生两个效果:Content-Length 字段会被忽略。基于长连接持续推送动态内容。

### 27、HTTP 如何处理大文件的传输？

对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。

- 服务器需要设置 Accept-Ranges: none 响应头。用来告知客户端这边是支持范围请求的。
- 客户端发起范围请求带上 Range: bytes=x-y 服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码。请求数据的范围是 x 到 y。
- 服务端收到范围请求返回 Content-Range: bytes x-y/size 字段，这个字段的格式根据请求头中 Range 字段的不同而有所差异。范围是 x 到 y 大小是 size。

### 28、HTTP 中如何处理表单数据的提交？

在 http 中，由于表单提交一般是 POST 请求，很少考虑 GET，因此这里我们主要讨论 post 请求的情况。post 有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值:

- application/x-www-form-urlencoded 普通的表单提交
- multipart/form-data 包含文件的提交。没有必要做 URL 编码，因为带来巨大耗时的同时也占用了更多的空间。

- 对于 application/x-www-form-urlencoded 格式的表单内容，有以下特点:
  - 其中的数据会被编码成以&分隔的键值对
  - 字符以 URL 编码方式编码。

// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> (最终形式)"a%3D1%26b%3D2"

- 对于 multipart/form-data 而言:
  - 请求头中的 Content-Type 字段会包含 boundary，且 boundary 的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。
  - 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如 Content-Type，在最后的分隔符会加上--表示结束。

### 29、HTTP1.1 如何解决 HTTP 的队头阻塞问题？

- 并发连接。对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。
- 域名分片。利用二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

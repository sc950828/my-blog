### 1、什么是跨域
  所以对于同源，只要 URI 中协议名、主机名(域名)、端口三者有其中一条不同，则视为不同源。不同源之间请求资源，则为跨域。

### 2、跨域的限制
* Cookie、LocalStorage sessionStorage和 IndexDB 无法读取。
* DOM 无法获得。
* AJAX 请求被拦截。

### 3、解决跨域
* 解决跨域问题可以有两个方向，第一是绕开浏览器限制，第二是通过浏览器支持的方式来允许跨域。
  * 绕开浏览器限制
    * 开发环境下使用webpack-dev-server 配置proxy
    * 生产环境下使用nginx 配置proxy_pass
  * 通过浏览器支持的方式来允许跨域
    * cors跨域资源共享

### 4、cors跨域资源共享
* 这种跨域解决方案只需要服务端的设置，分简单请求和非简单请求。
  * 简单请求
    ```
    （1) 请求方法是以下三种方法之一：
      HEAD
      GET
      POST
    （2）HTTP的头信息不超出以下几种字段：
      Accept
      Accept-Language
      Content-Language
      Last-Event-ID
      Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
    ```
  * 非简单请求
    * 不满足简单请求的就是非简单请求
  * 跨域
    简单请求跨域请求只会发送一次请求，非简单请求在通信前会发送一次http查询(option)请求，当浏览器得到肯定答复时，才会发送正式的请求。
  * 简单请求跨域
    * 服务器response需要设置Access-Control-Allow-Origin字段，该字段是必须的，值为*或者具体的域名
  * 非简单请求跨域
    * 服务器response需要设置Access-Control-Allow-Origin字段，该字段是必须的，值为*或者具体的域名
    * 服务器response需要设置Access-Control-Allow-Headers:该字段必须，表明服务器支持的所有头信息字段
    * 服务器response需要设置Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法
    * Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期
  * 注意不管简单请求还是非简单请求
    * 服务器response可以设置Access-Control-Allow-Credentials:该字段可选，其值类型是布尔型，表示是否允许发送Cookie。默认情况下Cookie不包括在CORS请求中。当设为true时表示服务器明确许可，Cookie可以包含在请求中一起发送给服务器。
    * 如果服务器设置了Access-Control-Allow-Credentials客户端请求需要设置withCredentials = true，并且Access-Control-Allow-Origin的值必须是明确的域名不能是*

### 5、跨域简单请求和非简单请求
* 简单请求
  * 浏览器检测到请求是 CORS 请求, 添加一个origin字段(其中包含页面源信息: 协议、域名、端口) ====> 服务端收到后作相应的处理(对比origin, 服务端判断这个源是否接受)返回结果给浏览器  ====> 浏览器检查响应头是否允许跨域信息  ====> 允许, 那就当做没事发生。 不允许, 浏览器抛出相应的错误信息。
* 非简单请求
  * 复杂请求在发生请求时, 如果是 CORS 请求，浏览器预先发送一个 option 请求。浏览器这种行为被称之为预检请求。

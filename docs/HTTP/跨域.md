### 1、什么是跨域

- 对于同源，只要 URI 中协议名、主机名(域名)、端口三者有其中一条不同，则视为不同源。不同源之间请求资源，则为跨域。
- 同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

### 2、跨域的限制

- 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
- 是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
- 当前域下 ajax 无法发送跨域请求。

### 3、解决跨域

- 解决跨域问题可以有两个方向，第一是绕开浏览器限制，第二是通过浏览器支持的方式来允许跨域。
  - 绕开浏览器限制
    - 开发环境下使用 webpack-dev-server 配置 proxy
    - 生产环境下使用 nginx 配置 proxy_pass
  - 通过浏览器支持的方式来允许跨域
    - cors 跨域资源共享

### 4、cors 跨域资源共享

- 这种跨域解决方案只需要服务端的设置，分简单请求和非简单请求。
  - 简单请求
    ```
    （1） 请求方法是以下三种方法之一：
      HEAD
      GET
      POST
    （2）HTTP的头信息不超出以下几种字段：
      Accept
      Accept-Language
      Content-Language
      Last-Event-ID
      Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
    ```
  - 非简单请求
    - 不满足简单请求的就是非简单请求
  - 跨域
    简单请求跨域请求只会发送一次请求，非简单请求在通信前会发送一次 http 查询(option)请求，当浏览器得到肯定答复时，才会发送正式的请求。
  - 简单请求跨域
    - 服务器 response 需要设置 Access-Control-Allow-Origin 字段，该字段是必须的，值为\*或者具体的域名
  - 非简单请求跨域
    - 服务器 response 需要设置 Access-Control-Allow-Origin 字段，该字段是必须的，值为\*或者具体的域名
    - 服务器 response 需要设置 Access-Control-Allow-Headers:该字段必须，表明服务器支持的所有头信息字段
    - 服务器 response 需要设置 Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法
    - Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期
  - 注意不管简单请求还是非简单请求
    - 服务器 response 可以设置 Access-Control-Allow-Credentials:该字段可选，其值类型是布尔型，表示是否允许发送 Cookie。默认情况下 Cookie 不包括在 CORS 请求中。当设为 true 时表示服务器明确许可，Cookie 可以包含在请求中一起发送给服务器。
    - 如果服务器设置了 Access-Control-Allow-Credentials 客户端请求需要设置 withCredentials = true，并且 Access-Control-Allow-Origin 的值必须是明确的域名不能是\*

### 5、跨域简单请求和非简单请求

- 简单请求
  - 浏览器检测到请求是 CORS 请求, 添加一个 origin 字段(其中包含页面源信息: 协议、域名、端口) ====> 服务端收到后作相应的处理(对比 origin, 服务端判断这个源是否接受)返回结果给浏览器 ====> 浏览器检查响应头是否允许跨域信息 ====> 允许, 那就当做没事发生。 不允许, 浏览器抛出相应的错误信息。
- 非简单请求
  - 复杂请求在发生请求时, 如果是 CORS 请求，浏览器预先发送一个 option 请求。浏览器这种行为被称之为预检请求。

### 6、解决跨域的方法我们可以根据我们想要实现的目的来划分。

- 首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。

  - 将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。

- 如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。

  - 使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听
    函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

  - 使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 wi
    ndow.name 中的数据了，这种方式的好处是可以传输的数据量大。

  - 使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。

- 如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。

  - 使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的
    引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的
    包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。

  - 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求
    ，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

  - 使用 websocket 协议，这个协议没有同源限制。

- 使用服务器来代理跨域的访问请求（nginx），就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

### 7、手写一个 jsonp

```js
function jsonp(url, params, callback) {
  // 判断是否含有参数
  let queryString = url.indexOf("?") === "-1" ? "?" : "&";

  // 添加参数
  for (var k in params) {
    if (params.hasOwnProperty(k)) {
      queryString += k + "=" + params[k] + "&";
    }
  }

  // 处理回调函数名
  let random = Math.random()
      .toString()
      .replace(".", ""),
    callbackName = "myJsonp" + random;

  // 添加回调函数
  queryString += "callback=" + callbackName;

  // 构建请求
  let scriptNode = document.createElement("script");
  scriptNode.src = url + queryString;

  window[callbackName] = function() {
    // 调用回调函数
    callback(...arguments);

    // 删除这个引入的脚本
    document.getElementsByTagName("head")[0].removeChild(scriptNode);
  };

  // 发起请求
  document.getElementsByTagName("head")[0].appendChild(scriptNode);
}
```

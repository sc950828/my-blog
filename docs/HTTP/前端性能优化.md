### 1、webpack性能优化
* webpack的性能瓶颈
  * 构建时间长
  * 构建的体积大
* 优化
  * loader优化
    * 使用include exclude选择文件，避免不必要的转义。
    * 将转译的结果缓存至文件系统 cacheDirectory=true 例如loader: 'babel-loader?cacheDirectory=true'
  * 第三方库打包优化
    * 使用DllPlugin处理第三方依赖库
    * DllPlugin会把第三方库单独打包到一个文件，不会跟业务代码一起打包。只有第三方依赖库更新了才会重新打包。
    * 使用DllPlugin我们需要配置dll的专属配置文件和webpack.config.js
    * 使用Happypack将 loader 由单进程转为多进程
    * 使用webpack-bundle-analyzer插件，打包文件结构可视化，一眼就能看出哪些文件体积大。
    * 使用Tree-Shaking插件，删除未使用的代码 它更适合用来处理模块级别的冗余代码
    * 使用compression-webpack-plugin插件，开启gzip压缩。new CompressionWebpackPlugin()

### 2、图片优化
* 根据具体场景选择适当格式的图片
  * jpg 有损压缩 大图片banner图可以选用这个格式的图片，但是不支持透明度处理
  * png 无损压缩 质量好 可以用作logo 支持透明处理。缺点是体积大
  * svg 文本文件、体积小、不失真、兼容性好 可用作logo 图标 缺点是渲染成本高消耗cpu性能
  * base64 减少http请求 将图片变为字符串直接可以写入html文档中。
  * 雪碧图 减少http请求 将多个图标合并到一张图片上面，使用css的background-position进行定位
  * WebP WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片。缺点是兼容性不好

### 3、CDN存放静态资源
*  CDN指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。
* 虽然有了缓存但是还是需要CDN，因为CDN可以提升首次请求的响应能力，CDN 的核心点有两个，一个是缓存，一个是回源。
  * “缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程。
  * “回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。

### 4、前端性能优化的方法
* 压缩css js
* 减少http请求 雪碧图，合并请求
* 静态资源放cdn
* 减小cookie的大小
* 使用缓存技术 manifest 浏览器的强缓存 协商缓存

### 5、html优化
* 避免在html里面写内联的css代码。
* 删除不必要的标签，使dom更清晰
* 使用语义化标签，便于别人理解，便于seo
* 懒加载（图片懒加载、下拉加载更多）

### 6、css优化
* 避免使用calc计算函数和!important
* 抽取公共的样式，复用代码
* 图片根据实际情况选取jpg还是png图片
* 尽量使用准确的id 类名选择器不要使用通配符 不要过度嵌套
* 上线前压缩
* icon使用雪碧图
* css放html文档的前面
* 不要使用@import 应该使用link标签 使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。

### 7、js优化
* 抽取公共代码复用，模块化
* 减少DOM 查询，对 DOM 查询做缓存
* 减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）涉及到跨线程通信
* 使用async defer异步加载js
* js放body后面，js会阻塞dom的渲染，先让页面展示出来
* 上线前压缩

### 8、图片懒加载原理
* 所有图片的初始src为一张默认的图片，data-src为图片的真实链接
* 获取浏览器可视区域的高度 window.innerHeight || document.documentElement.clientHeight
* 获取滚动的高度document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset
* 滚动的时候监听获取图片距离顶部的距离，当可视区域高度+浏览器滚动的高度>图片距离顶部的高度(offsetTop)的时候就需要把真实链接赋值给src
* 第二种计算是浏览器可视区域的高度 - imgs[i].getBoundingClientRect().top > 0的时候就需要把真实链接赋值给src

### 9、利用 Chrome Dev Tools 进行页面性能分析
* 1.performance 可以在顶部看到fps cpu情况，在中间可以看main火焰图得知资源函数的情况domcontentloaded onload事件等
  在底部有summary饼图，可以看到loading script render paint system各自占用的时间情况。
* 2. 我们也可以安装谷歌插件LightHouse为我们的页面生成报告，或者使用npm安装npm install -g lighthouse。从 Chrome 60 开始，DevTools 中直接加入了基于 LightHouse 的 Audits 面板。LightHouse或者Audits会从页面性能、PWA（渐进式 Web 应用）、可访问性（无障碍）、最佳实践、SEO 五项指标跑分。

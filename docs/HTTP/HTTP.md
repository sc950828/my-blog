### http 是什么？

- http 是超文本传输协议，它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。属于网络层级中的应用层。
- http 默认端口 80，https 默认端口 443。

### http 的特点是什么？

- 无状态 就是 http 传输是没有记忆能力，第一次传送的数据如果第二次还要传的话，需要重新传。
- 无连接 传送完数据之后就断开了连接。
- 媒体独立 可以传送任何数据类型。

### 连接模式

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。

### 网络层级

物理层

- 物理层更多的是规定一种传输标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。在这一层，数据的单位称为比特（bit）。0 和 1。通过物理手段 ( 网线，光纤，无线 ) 将设备连接在一起，传输 0/1 电信号。

数据链路层 常见的设备有网桥和交换机。

- 数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。就是传输有地址的帧。

- 下层的物理层不能规定不同 0/1 组合的信号代表什么意义，所以在数据链路层规定了一套协议，专门给 0/1 信号进行分组，规定不同的组代表的是什么意思，从而让双方计算机都能够进行识别，这个协议就是我们常说的 以太网协议。

- 以太网协议规定一组电信号构成一个数据包，我们把这个数据包称为 帧 ，每一个帧由 标头 和 数据 两部分组成。

- 标头 Head ，18 个字节组成，标头中包含这个 桢 是由谁发送、发送给谁这些信息，所以标头主要是一些说明数据 例如发送者/接受者等信息

- 数据 Data ，46-1500 个字节组成，里面主要是发送者想给接收者的内容。

- 把一台计算机的数据通过物理层和数据链路层发送给另外一台计算机，怎么标识对方以及怎么知道对方的地址呢？ 唯一标示 MAC 地址 出现了。进入网络的每一台计算机，都会有网卡接口，每一个网卡都会有一个唯一的地址，就是所谓的 MAC 地址。我们可以通过网络层的 ARP 协议 来得知对方的 MAC 地址。

- 虽然计算机 A 知道计算机 B 的 MAC 地址，但是却不知道 B 是在哪一路上，所以为了解决这个问题，广播 这个概念就出现了

- 在同一子网络，就是我们常说的局域网中，计算机通过广播来通信，即向同子网中全部计算机发送数据包，其它计算机根据数据包中接收者的 MAC 地址 来判断是否接收数据包。会取出数据包中的 MAC 地址 与自身的 MAC 地址 对比，如相同就接收这个数据包，否则就丢弃这个数据包 ( 丢包 )，这种方式我们称之为 广播。

网络层 ip

- 主要负责寻找地址和路由选择。在这一层数据的单位被称为数据包。
- ip 地址有 5 种 这个地址由 32 位的二进制数组成。

  - A 类：1.0.0.0~126.255.255.255
  - B 类：128.0.0.0~191.255.255.255
  - C 类：192.0.0.0~223.255.255.255
  - D 类：224.0.0.0~239.255.255.255 用于组播
  - E 类：240.0.0.0~254.255.255.255 用于科研
  - 127.0.0.0~127.255.255.255 用于环回测试

- IP 地址 分为两部分，前面一部分代表网络，后面一部分代表主机，但是网络部分和主机部分所占用的二级制位数是不固定的。但是我们怎么知道网络部分和主机部分分别占多少位呢，这就需要用到子网掩码。比如 255.255.255.0 就是一个子网掩码。

- 知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位，我们只需要把 IP 地址 与他的子网掩码做一个 ( and ) 运算，然后把各自的结果进行比较就行了。也就是说有了两台计算机的 IP 地址 和 子网掩码 ，我们就可以判断他们是否处在同一子网当中了。

- 假设他们处在同一子网当中，计算机 A 要和计算机 B 发送数据时，我们通过是 网络层的 ARP 协议 来得到计算机的 MAC 地址的。

- ARP 协议 也是通过广播的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 IP 地址，对方收到这个数据之后，会取出 IP 地址 与自身的对比，相同则会把自己的 MAC 地址 回复给对方，否则就丢弃这个数据包，这样计算机 A 就知道计算机 B 的 MAC 地址 了

- 如果两台计算机的 IP 不是处于同一个子网之中，这个时候我们就会把数据包发送给网关，然后让网关帮我们进行转发。

传输层 tcp udp

- 在电脑端获取数据包给不同的应用程序。通过端口号区分。
- 传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。
- 端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。
- 在这一层数据的单位被称为数据段。

会话层 TLS SSL

表示层

应用层 http

- 应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。区分是发送报文还是接收报文。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

- 我们遨游网络时经常用到的 HTTP 协议、文件传输用的 FTP 协议、电子邮件发送的 SMTP、域名解析的 DNS 协议、远程登录的 Telnet 协议等等都是属于应用层的。

- Socket，套接字。它是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作封装成几个简单的接口供应用层调用，从而实现进程在网络中的通信。

### ARP(地址转换协议，属于网络层) 协议的工作原理？

MAC 地址一般来讲是不会变的，设备在生产时就被“烙”上了 唯一的标识，这个 唯一的标识 就是 MAC 地址。

网络层的 ARP 协议完成了 IP 地址与 MAC 地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

### 套接字（socket）概念

套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

应用层通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

### 多路复用与多路分解

将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。

在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。

无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端口号，那么不同的报文段将会转交到同一个 UDP 套接字中。

面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了 源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个 值来将报文段定向到相应的套接字。

### 请求行 响应行包括什么？

- 请求行有协议版本 请求路径 请求方法
- 响应行有协议版本 状态码 相应的状态信息(原因)

### 常见的请求头有什么?

    Accept 可以接受的数据类型
    Accept-Charset 可接受的字符集
    Accept-Language 可接受的响应内容语言列表
    Accept-Encoding 告诉服务器，客户机支持的数据压缩格式。
    Content-Type 请求参数的数据类型
    Authorization HTTP授权的授权证书 一般我们用来存放token Authorization: Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ==
    Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）
    Host 请求服务器的域名及端口号(服务端)
    Origin: 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
    Referer: 当前发送请求的域名及端口号及参数，请求资源的完整URI(客户端)https:/localhost:8081/link?query=xxxxx
    Remote Address 服务器ip和端口
    Referrer-Policy（来源协议）用来规定什么情况下显示Referer字段及refer字段内显示多少信息。
    Cookie cookie信息
    User-Agent 浏览器的一些信息
    Date 客户机通过这个头告诉服务器，客户机当前请求时间
    Cache-Control 是否使用缓存 max-age no-cache no-store等等
    If-Modify-Since 协商缓存标志 值等于上次响应的last-Modify的值
    If-None-Match 协商缓存标志 值等于上次响应的ETag字符串

    对 Accept 系列字段了解多少？

    对于 Accept 系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。
    浏览器告知服务器自己对这四个部分想要收到特定类型的数据。

    客户端接收数据想要的数据格式 Accept

    - text： text/html, text/plain, text/css 等
    - image: image/gif, image/jpeg, image/png 等
    - audio/video: audio/mpeg, video/mp4 等
    - application: application/json, application/javascript, application/pdf, application/octet-stream

    客户端接收数据想要的数据压缩格式 Accept-Encoding

    - gzip: 当今最流行的压缩格式
    - deflate: 另外一种著名的压缩格式
    - br: 一种专门为 HTTP 发明的压缩算法

    客户端接收数据想要的语言类型 Accept-Language

    - Accept-Language: zh-CN, zh, en

    客户端就收数据想要的字符集 Accept-Charset

    - Accept-Charset: charset=utf-8

### 常见的响应头有什么？

    Expires 是否强缓存 (老版本)是个将来的时间戳，有问题后来使用cache-control
    Date 服务端发送资源时的服务器时间
    Cache-Control 是否强缓存 他的max-age值表示在多少时间内有效
    Content-Type 响应的数据类型
    Content-Encoding 告诉浏览器数据压缩的格式
    Access-Control-Allow-Origin 指定哪些域名可以访问服务器
    Access-Control-Allow-Methods 哪些方法
    Access-Control-Allow-Headers 哪些请求头
    Last-Modified 是否协商缓存 是个时间戳 (老版本)有问题后来使用Etag，比如编辑了文件并没有改变东西会有问题
    ETag 是否使用协商缓存 由服务端为每个文件生成唯一的字符
    Set-Cookie: 服务端发送的cookie

### 常见的通用标头有什么？

    Date
    Cache-Control
    Connection

### 常见的实体标头有什么？

    Content-Length
    Content-Language
    Content-Encoding

### 状态码表示什么含义？列出一些常见的状态码？

    1xx 接收的请求正在处理
    2xx 请求正常处理完毕
    3xx 需要进行附加操作完成请求 比如重定向
    4xx 服务端无法处理请求 客户端错误
    5xx 服务端处理请求出错

- 101 Switching Protocols。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。
- 200 成功 通常在响应体中放有数据。
- 204 No Content 含义与 200 相同，但响应头后没有 body 数据。
- 206 Partial Content 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断电续传，当然也会带上相应的响应头字段 Content-Range。
- 301 永久重定向 比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。
- 302 临时重定向 会改变请求方法 把 post 改为 get。
- 307 临时重定向 不会改变请求方式
- 304 Not Modified: 当协商缓存命中时会返回这个状态码。
- 400 请求错误 客户端错误
- 401 未授权
- 403 请求被拒绝
- 404 资源缺失找不到
- 500 服务端错误
- 501 Not Implemented: 表示客户端请求的功能还不支持。
- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
- 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务

### 代理 网关？

代理分为正向代理反向代理

- 正向代理
  - 由客户端向代理服务器发出请求，并指定目标访问服务器，然后，代理服务器向源服务器转交需求，并将获得的内容返回给客户端客户端知道真正要请求的服务器，服务端不知道真实的客户端是谁。
- 反向代理
  - 由客户端向代理服务器发出请求，代理服务器判断目标服务器，然后向目标服务器发送请求获取响应，然后把数据发送给客户端。对客户端来说并不知道真正的服务器是谁，把代理服务器当成服务器。反向代理器一般用来实现负载平衡。

代理接收请求转发请求 接收响应转发响应

- 缓存代理。代理转发响应时 缓存代理会将数据缓存到自己的服务器上 下次请求来的时候直接将缓存的数据返回
- 负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性 hash、LRU(最近最少使用)等等。
- 保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
- 透明代理 只负责转发请求和响应 不对数据进行操作
- 代理相关头部字段
  - Via 假如有一个客户端 -> 代理 1 -> 代理 2 -> 源服务器的请求。在源服务器收到请求后，会在请求头拿到这个字段:Via: proxy_server1, proxy_server2。而源服务器响应时，最终在客户端会拿到这样的响应头:Via: proxy_server2, proxy_server1
  - X-Forwarded-For 字面意思就是为谁转发, 它记录的是请求方的 IP 地址(注意，和 Via 区分开，X-Forwarded-For 记录的是请求方这一个 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理 1，这个字段是客户端的 IP，从代理 1 到代理 2，这个字段就变为了代理 1 的 IP。意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。)。
  - X-Real-IP 是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP。
    相应的，还有 X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。

网关

- 网关会接收请求转发请求 接收响应转发响应 而且还能提供非 http 协议服务。

### 加密方式有哪些？

- 公开密钥加密(非对称加密) 公钥是公开的使用公钥加密 私钥只有自己知道使用私钥解密(SSL)
- 共享密钥加密(对称加密) 加密解密使用同一把密钥 传输密钥不太安全

### CDN

CDN 全称为内容分发网络 (Content Delivery Network)，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，以提高用户访问网站的相应速度。

分发服务系统

分发服务系统的基元是 Cache 设备，它会同步源站点的内容并负责响应用户的访问请求，把缓存在本地的内容快速的提供给用户。

负载均衡系统

对发起请求的用户进行访问调度，确定提供给用户的最终实际访问地址。该系统分为全局负载均衡 (GSLB) 和本地负载均衡 (SLB)。GBLB 主要根据“就近原则”，通过对每个服务节点进行最优判断，向用户提供最合适的 Cache 设备。SLB 主要负责节点内部的设备负载均衡。

CDN 厂商做域名解析，它也是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容，CDN 厂商的域名解析服务器用户量多，被访问的次数也多，域名解析服务器的 A 记录基本上会被各地运营商的 DNS 一直缓存着，所以服务效果也是最好的。

### ARQ 协议

ARQ 协议就是超时重传机制。通过确认和超时机制保证数据的正确到达，是 OSI 模型中传输层和数据链路层的错误纠正协议之一，在不可靠的服务基础上实现可靠的信息传输。ARQ 协议包含停止等待 ARQ 协议和连续 ARQ 协议，拥有错误检测，正面确认，超时重传和负面确认及重传等机制。

一、停止等待 ARQ 协议

停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认 回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。

对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余 分组的确认。当收到分组损坏的情况的时候，直接丢弃。

使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。

二、连续 ARQ 协议

连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的 确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。

滑动窗口协议

使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发 送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分 组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定 时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没 有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分组。

接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，所以发送窗口可以移动到已确认分组的后面。

滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。

选择重传协议

因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。

选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组， 已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协 议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的 定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分 组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。

在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分 组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。

### websocket

特点

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。

WebSocket 连接必须由浏览器发起

```
请求
GET ws://localhost:3000/ws/chat HTTP/1.1
Host: localhost
Upgrade: websocket 表示这个连接将要被转换为WebSocket连接；
Connection: Upgrade 表示这个连接将要被转换为WebSocket连接；
Origin: http://localhost:3000
Sec-WebSocket-Key: client-random-string 标识这个连接
Sec-WebSocket-Version: 13 指定了WebSocket的协议版本

响应
HTTP/1.1 101 Switching Protocols  响应是101 表示本次连接的HTTP协议被更改为webSocket
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: server-random-string
```

### 常见的 http 请求方法

`GET`方法

- 发送一个请求来取得服务器上的某一资源

`POST`方法

- 向`URL`指定的资源提交数据或附加新的数据

`PUT`方法

- 跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。`PUT`指定了资源在服务器上的位置，而`POST`没有

`HEAD`方法

- 只请求页面的首部

`DELETE`方法

- 删除服务器上的某资源

`OPTIONS`方法

- 它用于获取当前`URL`所支持的方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息

`TRACE`方法

- `TRACE`方法被用于激发一个远程的，应用层的请求消息回路

`CONNECT`方法

- 把请求连接转换到透明的`TCP/IP`通道

### 1、http 是什么？

- http 是超文本传输协议，它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。属于网络层级中的应用层。
- http 默认端口 80，https 默认端口 443。

### 2、http 的特点是什么？

- 无状态 就是 http 传输是没有记忆能力，第一次传送的数据如果第二次还要传的话，需要重新传。
- 无连接 传送完数据之后就断开了连接。
- 媒体独立 可以传送任何数据类型。

### 3、连接模式

HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。

### 4、网络层级

物理层

- 物理层更多的是规定一种传输标准，他并不管物理介质具体是什么，比如电线杆上是光纤还是双绞线，只要你能按物理层规定的标准传输数据就行。在这一层，数据的单位称为比特（bit）。

数据链路层 常见的设备有网桥和交换机。

- 数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。
- 把需要传输的数据封装成帧，在链路层就叫数据帧。
- 透明传输 把数据原原本本的传输。
- 差错控制 判断是否有数据丢失。
- 差错纠正 把丢失的数据重新传输。

网络层 ip

- 主要负责寻找地址和路由选择，网络层还可以实现阻塞控制、网际互联等。在这一层数据的单位被称为数据包。
- ip 地址有 5 种
  - A 类：1.0.0.0~126.255.255.255
  - B 类：128.0.0.0~191.255.255.255
  - C 类：192.0.0.0~223.255.255.255
  - D 类：224.0.0.0~239.255.255.255 用于组播
  - E 类：240.0.0.0~254.255.255.255 用于科研
  - 127.0.0.0~127.255.255.255 用于环回测试

传输层 tcp udp

- 传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。
- 端口号可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）。
- 在这一层数据的单位被称为数据段。

会话层 TLS SSL

表示层

应用层 http

- 应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。区分是发送报文还是接收报文。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

### 5、http 请求响应步骤

- tcp 的三次握手，建立 tcp 的连接
- 客户端发送请求，请求包括请求行 请求头 空行 请求体
- 服务器发送响应，响应包括响应行 响应头 空行 响应体
- tcp 四次挥手，断开 tcp 连接

### 6、请求行 响应行包括什么？

- 请求行有协议版本 请求路径 请求方法
- 响应行有协议版本 状态码 相应的状态信息(原因)

### 7、请求头常见的有什么?

    Accept 可以接受的数据类型
    Accept-Charset 可接受的字符集
    Accept-Language 可接受的响应内容语言列表
    Accept-Encoding 告诉服务器，客户机支持的数据压缩格式。
    Content-Type 请求参数的数据类型
    Authorization HTTP授权的授权证书 一般我们用来存放token Authorization: Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ==
    Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）
    Host 请求服务器的域名及端口号(服务端)
    Origin: 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
    Referer: 当前发送请求的域名及端口号及参数，请求资源的完整URI(客户端)https:/localhost:8081/link?query=xxxxx
    Cookie cookie信息
    User-Agent 浏览器的一些信息
    Date 客户机通过这个头告诉服务器，客户机当前请求时间
    Cache-Control 是否使用缓存 max-age no-cache no-store等等
    If-Modify-Since 协商缓存标志 值等于上次响应的last-Modify的值
    If-None-Match 协商缓存标志 值等于上次响应的ETag字符串

### 8、响应头常见的有什么？

    Expires 是否强缓存 (老版本)是个将来的时间戳，有问题后来使用cache-control
    Date 服务端发送资源时的服务器时间
    Cache-Control 是否强缓存 他的max-age值表示在多少时间内有效
    Content-Type 响应的数据类型
    Content-Encoding 告诉浏览器数据压缩的格式
    Access-Control-Allow-Origin 指定哪些域名可以访问服务器
    Access-Control-Allow-Methods 哪些方法
    Access-Control-Allow-Headers 哪些请求头
    Last-Modified 是否协商缓存 是个时间戳 (老版本)有问题后来使用Etag，比如编辑了文件并没有改变东西会有问题
    ETag 是否使用协商缓存 由服务端为每个文件生成唯一的字符
    Set-Cookie: 服务端发送的cookie

### 9、几种常见的 content-type

    （1）application/x-www-form-urlencoded

    浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

    （2）multipart/form-data

    该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

    （3）application/json

    告诉服务器消息主体是序列化后的 JSON 字符串。

    （4）text/xml

    该种方式主要用来提交 XML 格式的数据。

### 10、tcp/ip

- TCP/IP 是因特网的通信协议。
- tcp 在传输层是传输控制协议
- ip 在网络层

### 11、状态码表示什么含义？列出一些常见的状态码？

    1xx 接收的请求正在处理
    2xx 请求正常处理完毕
    3xx 需要进行附加操作完成请求 比如重定向
    4xx 服务端无法处理请求 客户端错误
    5xx 服务端处理请求出错

- 101 Switching Protocols。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。
- 200 成功 通常在响应体中放有数据。
- 204 No Content 含义与 200 相同，但响应头后没有 body 数据。
- 206 Partial Content 顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断电续传，当然也会带上相应的响应头字段 Content-Range。
- 301 永久重定向 比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。
- 302 临时重定向 会改变请求方法 把 post 改为 get。
- 307 临时重定向 不会改变请求方式
- 304 Not Modified: 当协商缓存命中时会返回这个状态码。
- 400 请求错误 客户端错误
- 401 未授权
- 403 请求被拒绝
- 404 资源缺失找不到
- 500 服务端错误
- 501 Not Implemented: 表示客户端请求的功能还不支持。
- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
- 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务

### 12、代理 网关是什么？

代理接收请求转发请求 接收响应转发响应

- 缓存代理。代理转发响应时 缓存代理会将数据缓存到自己的服务器上 下次请求来的时候直接将缓存的数据返回
- 负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性 hash、LRU(最近最少使用)等等。
- 保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
- 透明代理 只负责转发请求和响应 不对数据进行操作
- 代理相关头部字段
  - Via 假如有一个客户端 -> 代理 1 -> 代理 2 -> 源服务器的请求。在源服务器收到请求后，会在请求头拿到这个字段:Via: proxy_server1, proxy_server2。而源服务器响应时，最终在客户端会拿到这样的响应头:Via: proxy_server2, proxy_server1
  - X-Forwarded-For 字面意思就是为谁转发, 它记录的是请求方的 IP 地址(注意，和 Via 区分开，X-Forwarded-For 记录的是请求方这一个 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理 1，这个字段是客户端的 IP，从代理 1 到代理 2，这个字段就变为了代理 1 的 IP。意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。)。
  - X-Real-IP 是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP。
    相应的，还有 X-Forwarded-Host 和 X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。

网关

- 网关会接收请求转发请求 接收响应转发响应 而且还能提供非 http 协议服务。

### 13、用户认证有哪些方式？

    basic认证(不安全 base64不是加密方式)
      1.客户端发送请求
      2.服务端返回401 并携带www-Authenticate的响应头
      3.客户端填写用户名密码 在请求头Authorization: Basic 用户名密码base64处理 发送给服务端
      4.服务端认证成功返回200 失败返回401
    digest认证
    ssl客户端认证(一般使用证书 表单双重认证 但这种方式成本比较高)
      客户端发送请求
      服务端返回响应 需要客户端证书
      客户端发送证书
      服务端验证通过后 进行https的通信
    基于表单的认证(一般使用cookie来管理session 使用最为广泛)
      客户端发送用户名密码
      服务端返回Set-Cookie响应头 里面有sessionid
      客户端接收到cookie 保存到本地 以后每次请求都携带上Cookie请求头 里面是sessionid 这样就能维持客户端服务端会话了。

### 14、加密方式有哪些？

- 公开密钥加密(非对称加密) 公钥是公开的使用公钥加密 私钥只有自己知道使用私钥解密(SSL)
- 共享密钥加密(对称加密) 加密解密使用同一把密钥 传输密钥不太安全

### 15、正向代理 反向代理是什么？

- 正向代理
  - 由客户端向代理服务器发出请求，并指定目标访问服务器，然后，代理服务器向源服务器转交需求，并将获得的内容返回给客户端客户端知道真正要请求的服务器，服务端不知道真实的客户端是谁。
- 反向代理
  - 由客户端向代理服务器发出请求，代理服务器判断目标服务器，然后向目标服务器发送请求获取响应，然后把数据发送给客户端。对客户端来说并不知道真正的服务器是谁，把代理服务器当成服务器。反向代理器一般用来实现负载平衡。

### 16、请求参数的传递，为什么在浏览器中看参数有时候在 Form Data 里有时候在 Request Payload 里有时又是 Query String Parameters

- 这个是由于请求头 Content-type 设置的原因
  - 当没有设置的时候，比如 get 请求 传参就会是 Query String Parameters
  - 当 Content-type 是 application/x-www-form-urlencoded 传参就会是 Form Data。这是普通表单 post 方式提交。
  - 其他情况就会是 Request Payload 比如 Content-type 是 application/json text/plain 等。

### 17、DNS 协议

DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号 端口。

### 18、多路复用与多路分解

将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。

在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。

无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端口号，那么不同的报文段将会转交到同一个 UDP 套接字中。

面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了 源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个 值来将报文段定向到相应的套接字。

### 19、ARQ 协议

ARQ 协议就是超时重传机制。通过确认和超时机制保证数据的正确到达，是 OSI 模型中传输层和数据链路层的错误纠正协议之一，在不可靠的服务基础上实现可靠的信息传输。ARQ 协议包含停止等待 ARQ 协议和连续 ARQ 协议，拥有错误检测，正面确认，超时重传和负面确认及重传等机制。

一、停止等待 ARQ 协议

停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认 回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。

对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余 分组的确认。当收到分组损坏的情况的时候，直接丢弃。

使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。

二、连续 ARQ 协议

连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的 确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。

滑动窗口协议

使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发 送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分 组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定 时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没 有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分组。

接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那 么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，所以发送窗口可以移动到已确认分组的后面。

滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况 的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。

选择重传协议

因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。

选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组， 已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协 议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的 定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分 组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。

在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分 组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。

### 位图

位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。

这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。常见的有 png、jpg 等。

### 矢量图

所谓矢量图，就是使用直线和曲线来描述的图形，构成这些图形的元素是一些点、线、矩形、多边形、圆和弧线等

它们都是通过数学公式计算获得的，具有编辑后不失真的特点。

矢量图以几何图形居多，图形可以无限放大，不变色、不模糊。常见的是 svg。

### 图片处理库

AlloyImage 基于 HTML 5 的专业级图像处理开源引擎。

- 基于多图层操作 —— 一个图层的处理不影响其他图层；
- 与 PS 对应的 17 种图层混合模式 —— 便于 PS 处理教程的无缝迁移；
- 多种基本滤镜处理效果 —— 基本滤镜不断丰富、可扩展；
- 基本的图像调节功能 —— 色相、饱和度、对比度、亮度、曲线等；
- 简单快捷的 API —— 链式处理、API 简洁易用、传参灵活；
- 多种组合效果封装 —— 一句代码轻松实现一种风格；
- 接口一致的单、多线程支持 —— 单、多线程切换无需更改一行代码，多线程保持快捷 API 特性。

blurify 是一个用于图片模糊的库。有三种模式

- css 模式：使用 filter 属性，默认模式；
- canvas 模式：使用 canvas 导出 base64；
- auto 模式：优先使用 css 模式，否则自动切换到 canvas 模式。

```js
import blurify from "blurify";

new blurify({
  images: document.querySelectorAll(".blurify"),
  blur: 6,
  mode: "css",
});

// or in shorthand

blurify(6, document.querySelectorAll(".blurify"));
```

cropperjs 是一款非常强大却又简单的图片裁剪工具，它可以进行非常灵活的配置，支持手机端使用，支持包括 IE9 以上的现代浏览器。

- 支持 39 个配置选项；
- 支持 27 个方法；
- 支持 6 种事件；
- 支持 touch（移动端）；
- 支持缩放、旋转和翻转；
- 支持在画布上裁剪；
- 支持在浏览器端通过画布裁剪图像；
- 支持处理 Exif 方向信息；
- 跨浏览器支持。

```js
// import 'cropperjs/dist/cropper.css';
import Cropper from "cropperjs";

const image = document.getElementById("image");
const cropper = new Cropper(image, {
  aspectRatio: 16 / 9,
  crop(event) {
    console.log(event.detail.x);
    console.log(event.detail.y);
    console.log(event.detail.width);
    console.log(event.detail.height);
    console.log(event.detail.rotate);
    console.log(event.detail.scaleX);
    console.log(event.detail.scaleY);
  },
});
```

compressorjs 是 JavaScript 图像压缩器。

fabric.js 是一个框架，可让你轻松使用 HTML5 Canvas 元素。它是一个位于 Canvas 元素之上的交互式对象模型，同时也是一个 「SVG-to-canvas」 的解析器。

Resemble.js 使用 HTML Canvas 和 JavaScript 来实现图片的分析和比较。图片比较工具。

Pica 可用于在浏览器中调整图像大小，没有像素化并且相当快。缩略图。

tui.image-editor 是使用 HTML5 Canvas 的全功能图像编辑器。它易于使用，并提供强大的过滤器。同时它支持对图像进行裁剪、翻转、旋转、绘图、形状、文本、遮罩和图片过滤等操作。

gif.js 是运行在浏览器端的 JavaScript GIF 编码器。它使用类型化数组和 Web Worker 在后台渲染每一帧，速度真的很快。

Sharp 的典型应用场景是将常见格式的大图像转换为尺寸较小，对网络友好的 JPEG，PNG 和 WebP 格式的图像。

### 获取图片尺寸

image-size 这个 Node.js 库已经帮我们实现了获取主流图片类型文件尺寸的功能

```js
// 同步方式
var sizeOf = require("image-size");

var dimensions = sizeOf("images/abao.png");
console.log(dimensions.width, dimensions.height);

// 异步方式
var sizeOf = require("image-size");

sizeOf("images/abao.png", function(err, dimensions) {
  console.log(dimensions.width, dimensions.height);
});
```

### 如何预览本地图片

```js
// 利用 HTML FileReader API，我们也可以方便的实现图片本地预览功能
<input type="file" accept="image/*" onchange="loadFile(event)">
<img id="output"/>
<script>
  const loadFile = function(event) {
    const reader = new FileReader();
    reader.onload = function(){
      const output = document.querySelector('output');
      output.src = reader.result;
    };
    reader.readAsDataURL(event.target.files[0]);
  };
</script>
```

### 手动实现图片压缩并上传到服务器

```js
// 利用 Canvas 对象提供的 toDataURL()方法
function compress(base64, quality, mimeType) {
  let canvas = document.createElement("canvas");
  let img = document.createElement("img");
  img.crossOrigin = "anonymous";
  return new Promise((resolve, reject) => {
    img.src = base64;
    img.onload = () => {
      let targetWidth, targetHeight;
      if (img.width > MAX_WIDTH) {
        targetWidth = MAX_WIDTH;
        targetHeight = (img.height * MAX_WIDTH) / img.width;
      } else {
        targetWidth = img.width;
        targetHeight = img.height;
      }
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      let ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, targetWidth, targetHeight); // 清除画布
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      let imageData = canvas.toDataURL(mimeType, quality / 100);
      resolve(imageData);
    };
  });
}

// 对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象
function dataUrlToBlob(base64, mimeType) {
  let bytes = window.atob(base64.split(",")[1]);
  let ab = new ArrayBuffer(bytes.length);
  let ia = new Uint8Array(ab);
  for (let i = 0; i < bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeType });
}

// 在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上
function uploadFile(url, blob) {
  let formData = new FormData();
  let request = new XMLHttpRequest();
  formData.append("image", blob);
  request.open("POST", url, true);
  request.send(formData);
}
```

### 1、首屏和白屏时间如何计算?

- 首屏时间的计算，可以由 Native WebView 提供的类似 onload 的方法实现，在 ios 下对应的是 webViewDidFinishLoad，在 android 下对应的是 onPageFinished 事件。
- 白屏的定义有多种。可以认为“没有任何内容”是白屏，可以认为“网络或服务异常”是白屏，可以认为“数据加载中”是白屏，可以认为“图片加载不出来”是白屏。场景不同，白屏的计算方式就不相同。
  - 方法 1：当页面的元素数小于 x 时，则认为页面白屏。比如“没有任何内容”，可以获取页面的 DOM 节点数，判断 DOM 节点数少于某个阈值 X，则认为白屏。
  - 方法 2：当页面出现业务定义的错误码时，则认为是白屏。比如“网络或服务异常”。
  - 方法 3：当页面出现业务定义的特征值时，则认为是白屏。比如“数据加载中”。

### 2、为什么会出现白屏

现在的前端框架， React、Vue、Angular 三大巨头已经占据了主导地位，市面上大多数前端应用也都是基于这三个框架或库完成，这三个框架有一个共同的特点，都是 JS 驱动(有个很大的 js 文件 index.html xx.css)，在 JS 代码解析完成之前，页面不会展示任何内容，也就是所谓的白屏。

用户是极其不喜欢看到白屏的，什么都没有展示，用户很有可能怀疑网络或者应用出了什么问题。 拿 Vue 来说，在应用启动时，Vue 会对组件中的 data 和 computed 中状态值通过 Object.defineProperty 方法转化成 set、get 访问属性，以便对数据变化进行监听。而这一过程都是在启动应用时完成的，这也势必导致页面启动阶段比非 JS 驱动（比如 jQuery 应用）的页面要慢一些。

### 3、白屏的解决方案？

SSR 服务端渲染。服务端渲染主要有两个目的，一是 SEO，二是加快内容展现。 在带来这两个好处的同时，我们的服务端渲染的成本也会加大。

在 index.html 文件里面实现写一些简单的 loading 样式。

预渲染。所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 prerender-spa-plugin 将页面在构建的过程中就渲染好，然后插入到 index.html 中，这样在页面启动之前首先看到的就是预渲染的页面了。但是预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定。因此我们最终没有选择预渲染方案。

使用骨架屏。其实也是预渲染,只是预渲染的是一个骨架屏。在构建的时候就把骨架屏插入到 index.html 页面。

- 我们可以手写骨架屏，但是需求一更改我们的骨架屏也需要修改，很麻烦。
- 使用 webpack 插件，page-skeleton-webpack-plugin 插件。通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了。

### 4、如何优化关键渲染路径？首屏优化

- 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

  - （1）关键资源的数量。
  - （2）关键路径长度。
  - （3）关键字节的数量。

- 关键资源数量是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

- 优化关键渲染路径的常规步骤如下：
  - （1）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。不必要的资源不加载。使用 webpack 的查看 Code Splitting 把应用从单个 bundle 拆分成单个 bundle + 多份动态代码的形式。就是组件懒加载，首屏只加载必要的资源。
  - （2）优化关键字节数以缩短下载时间。压缩，或者使用现代 js。现在浏览器越来越高级，我们没必要把代码再编译带 es5，我们需要做的，就是把代码编译到 ES2015+，然后为少数使用老旧浏览器的用户保留一个 ES5 标准的备胎即可。

```html
<!-- 具体的解决方法就是 <script type="module"> 标签。 -->
<!-- // 这个在新浏览器里面识别出来 就会加载 识别出nomodule就不会加载。老浏览器不会加载 -->
<script type="module" src="main.js"></script>
<!-- 这个在老浏览器里面会加载 -->
<script nomodule src="main.es5.js"></script>
```

- （3）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。分清楚依赖关系。使用内联 css

### 5、几乎所有业务的 JS 代码，都可以大致划分成以下几个大块：

- 基础框架，如 React、Vue 等，这些基础框架的代码是不变的，除非升级框架；
- Polyfill，对于使用了 ES2015+ 语法的项目来说，为了兼容性，polyfill 是必要的存在；
- 业务基础库，业务的一些通用的基础代码，不属于框架，但大部分业务都会使用到；
- 业务代码，特点是具体业务自身的逻辑代码。

基础框架代码我们可以设置 http 请求头来缓存。

Polyfill 的特点是非必需和不变，因为对于一台手机来说，需要哪些 polyfill 是固定的，当然也可能完全不需要 polyfill。去掉构建中静态的 polyfill，换而使用 polyfill.io 这样的动态 polyfill 服务，保证只有在需要时，才会引入 polyfill。

```js
// 具体的使用方法非常简单，只需要外链一个 js：
// 它会根据你的浏览器 UA 头，判断你是否支持某些特性，从而返回给你一个合适的 polyfill。
<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
```

业务基础库 使用 CommonChunksPlugin 或者 webpack4 的 SplitChunksPlugin 提取公用代码。

它们的区别就在于，CommonChunksPlugin 会找到多数模块中都共有的东西，并且把它提取出来（common.js），也就意味着如果你加载了 common.js，那么里面可能会存在一些当前模块不需要的东西。而 SplitChunksPlugin 采用了完全不同的 heuristics 方法，它会根据模块之间的依赖关系，自动打包出很多很多（而不是单个）通用模块，可以保证加载进来的代码一定是会被依赖到的。

业务代码 正确使用 Tree Shaking 减少业务代码体积。就是没有用到的代码打包的时候会自动丢弃。

### 1、首屏和白屏时间如何计算?

- 首屏时间的计算，可以由 Native WebView 提供的类似 onload 的方法实现，在 ios 下对应的是 webViewDidFinishLoad，在 android 下对应的是 onPageFinished 事件。
- 白屏的定义有多种。可以认为“没有任何内容”是白屏，可以认为“网络或服务异常”是白屏，可以认为“数据加载中”是白屏，可以认为“图片加载不出来”是白屏。场景不同，白屏的计算方式就不相同。
  - 方法 1：当页面的元素数小于 x 时，则认为页面白屏。比如“没有任何内容”，可以获取页面的 DOM 节点数，判断 DOM 节点数少于某个阈值 X，则认为白屏。
  - 方法 2：当页面出现业务定义的错误码时，则认为是白屏。比如“网络或服务异常”。
  - 方法 3：当页面出现业务定义的特征值时，则认为是白屏。比如“数据加载中”。

### 2、为什么会出现白屏

现在的前端框架， React、Vue、Angular 三大巨头已经占据了主导地位，市面上大多数前端应用也都是基于这三个框架或库完成，这三个框架有一个共同的特点，都是 JS 驱动，在 JS 代码解析完成之前，页面不会展示任何内容，也就是所谓的白屏。

用户是极其不喜欢看到白屏的，什么都没有展示，用户很有可能怀疑网络或者应用出了什么问题。 拿 Vue 来说，在应用启动时，Vue 会对组件中的 data 和 computed 中状态值通过 Object.defineProperty 方法转化成 set、get 访问属性，以便对数据变化进行监听。而这一过程都是在启动应用时完成的，这也势必导致页面启动阶段比非 JS 驱动（比如 jQuery 应用）的页面要慢一些。

### 3、白屏的解决方案？

SSR 服务端渲染。服务端渲染主要有两个目的，一是 SEO，二是加快内容展现。 在带来这两个好处的同时，我们的服务端渲染的成本也会加大。

预渲染。所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 puppeteer 或则 jsdom 将页面在构建的过程中就渲染好，然后插入到 index.html 中，这样在页面启动之前首先看到的就是预渲染的页面了。但是预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定。因此我们最终没有选择预渲染方案。

使用骨架屏。其实也是预渲染,只是预渲染的是一个骨架屏。在构建的时候就把骨架屏插入到 index.html 页面。

- 我们可以手写骨架屏，但是需求一更改我们的骨架 ping 也需要修改，很麻烦。
- 使用 webpack 插件，page-skeleton-webpack-plugin 插件。通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了。

### 4、如何优化关键渲染路径？首屏优化

- 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

  - （1）关键资源的数量。
  - （2）关键路径长度。
  - （3）关键字节的数量。

- 关键资源数量是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

- 优化关键渲染路径的常规步骤如下：
  - （1）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。不必要的资源不加载。
  - （2）优化关键字节数以缩短下载时间。压缩等
  - （3）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。分清楚依赖关系。

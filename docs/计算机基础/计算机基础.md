### 1、原码、反码和补码的介绍

- 原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。

- 正数的反码和其原码一样；负数的反码，符号位为 1，数值部分按原码取反。

  - 如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

- 正数的补码和其原码一样；负数的补码为其反码加 1。

  - [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；
  - [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

- 之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中
  我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。

### 2、进程 线程

- 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。
- 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。
- 对于操作系统来说,一个任务就是一个进程。
- 在一个进程内部,要同时做多件事,就需要同时运行多个“子任务”,我们把进程内的这些“子任务”称为线程。

### 3、进程间通信的方式？

- （1）管道通信
- （2）消息队列通信
- （3）信号量通信
- （4）信号通信
- （5）共享内存通信
- （6）套接字通信

### 4、线程的状态有哪些？

- 初始状态（New）
  - 线程对象被创建出来，便是初始状态，这时候线程对象只是一个普通的对象，并不是一个线程
- Runable
  - 就绪状态（Ready）：执行 start 方法之后，进入就绪状态，等待被分配到时间片。
  - 运行状态（Running）：拿到 CPU 的线程开始执行。处于运行时间的线程并不是永久的持有 CPU 直到运行结束，很可能没有执行完毕时间片到期，就被收回 CPU 的使用权了，之后将会处于等待状态。
- 等待状态（Waiting）
  - 等待状态分为有限期等待和无限期等待，所谓有限期等待是线程使用 sleep 方法主动进入休眠，有一定的时间限制，时间到期就重新进入就绪状态，再次等待被 CPU 选中。而无限期等待就有些不同了，无限期并不是指永远的等待下去，而是指没有时间限制，可能等待一秒也可能很多秒。至于进入等待的原因也不尽相同，可能是因为 CPU 时间片到期，也可能是因为一个比较耗时的操作（数据库），或者主动的调用 join 方法。
- 阻塞状态（Blocked）
  - 阻塞状态实际上是一种比较特殊的等待状态，处于其他等待状态的线程是在等着别的线程执行结束，等着拿 CPU 的使用权；而处于阻塞状态的线程等待的不仅仅是 CPU 的使用权，主要是锁标记，没有拿到锁标记，即便是 CPU 有空也没有办法执行。
- 终止线程（Terminated）
  - 已经终止的线程会处于该种状态。

### 5、位（bit）、字节（byte）、字符、编码之间的关系

- 位：数据存储的最小单位。每个二进制数字 0 或者 1 就是 1 个位；
- 字节：8 个位构成一个字节；即：1 byte (字节)= 8 bit(位)；1 KB = 1024 B(字节)；
- 字符：汉字、字母、数字、符号等都是字符。一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节；一般 gbk 编码下，一个汉字 字符 占用 2 个 字节；
- 字符集：字符组成的集合。Unicode 就是一个符号集（世界上所有符号的符号集）。
- 编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。（其实际是对字符集中字符进行编码，即：每个字符用二进制在计算中表示存储）；通俗的说：编码就是按照规则对字符进行翻译成对应的二进制数，在计算器中运行存储，用户看的时候（比如浏览器），在用对应的编码解析出来用户能看懂的；最常用的 utf-8 就是 Unicode 字符集的实现方式之一。它使用 1-4 个字节表示一个符号，根据不同的符号而变化字节长度。

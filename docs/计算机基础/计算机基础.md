### 1、操作系统的四个特征

    并发
    共享
    虚拟
    异步

### 2、并发是什么？和并行有啥区别？

并发只是把时间分成若干段，使多个任务交替的执行。比如你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发。

并行的关键是你有同时处理多个任务的能力。比如你一边用鼠标移动打游戏，同时语音嘴里说"队友挂机，真坑！", 这叫并行。

### 3、共享是什么？共享和并发有什么关系？

- 共享分为同时共享和互斥共享。
- 同时共享：系统中某些资源允许一个时间段内由多个进程(并发)同时对他进行访问。
- 互斥共享：系统中某些资源允许一个时间段内只能有一个进程对他进行访问。
- 我们把一段时间内只允许一个进程访问的资源称为独占资源，或临界资源。

### 4、虚拟

- 空分复用技术 如虚拟存储器
- 时分复用技术 如虚拟处理器

### 5、异步

CPU 正在执行一个进程，进程需要读取文件，读取文件可能要 1 个小时，那 CPU 不可能一直等一个小时，CPU 会继续把时间片分给别的进程，等文件读取完成了（类似 ajax 返回结果了），CPU 再继续执行之前被中断的进程。

所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。

### 6、什么是指令

指令是 CPU 能识别和执行的最基本命令。

指令分为特权指令和非特权指令。特权指令不允许用户程序使用。

CPU 通常有两种工作模式即：核心态和用户态。核心态既能执行特权指令又能执行非特权指令。用户态只能执行非特权指令。

应用程序又分为两种，内核程序和应用程序。普通应用程序只能执行非特权指令只能运行在用户态。内核应用程序既能执行特权指令又能执行非特权指令，运行在核心态。

### 7、中断

在程序运行过程中，系统出现了一个必须由 CPU 立即处理的情况，此时，CPU 暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。

- "用户态 ---> 核心态"是通过中断实现的。并且中断是唯一途径。
- "核心态 ---> 用户态"的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。

中断分为内中断和外中断

- 内中断常见的情况如程序非法操作(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，地址越界(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、浮点溢出(比如系统只能表示 1.1 到 5.1 的范围，你输入一个 100, 超出了计算机能处理的范围)，或者异常，陷入 trap（是指应用程序请求系统调用造成的，什么是系统调用）。
- 外中断常见的情况如 I/O 中断（由 I/O 控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给 CPU 一个 I/O 中断，告诉它已经准备好了）、时钟中断（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约 15ms 会进行一次线程调度，就是利用时钟中断来实现的）。

### 8、系统调用

应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O 操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。

系统调用分为设备管理 文件管理 进程控制 进程通信 内存管理。

### 9、进程 线程

- 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。
- 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。
- 对于操作系统来说,一个任务就是一个进程。
- 在一个进程内部,要同时做多件事,就需要同时运行多个“子任务”,我们把进程内的这些“子任务”称为线程。

进程间通信的方式？

- （1）管道通信
- （2）消息队列通信
- （3）信号量通信
- （4）信号通信
- （5）共享内存通信
- （6）套接字通信

线程的状态有哪些？

新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

就绪状态: 当线程对象调用了 start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。

运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

阻塞状态: 如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

- 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
- 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
- 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 10、内存

内存是计算机其它硬件设备与`CPU 沟通`的桥梁、中转站。程序执行前需要先放到内存中才能被 CPU 处理。

内存分配分为连续分配和非连续分配。连续分配是指用户进程分配的必须是一个连续的内存空间。

### 11、计算机的工作原理

计算机最基本的 5 大组成部分分别为：输入设备(比如键盘), 存储器(比如内存), 运算器(cpu), 控制器(cpu), 输出设备(显示器)。

当我们输入数据的时候，cpu 里的控制器会让输入设备把这些指令存储到存储器(内存)上。

控制器分析指令之后， 此时让存储器把数据发送到运算器里(控制器和运算器都在 cpu 里面)。这里需要注意，存储器既能存储数据，还能存储指令。

控制器控制运算器做数据的运算 并且将运算结果返回存储器。

控制器控制存储器将结果返回给输出设备。

### 12、CPU 及其工作过程

CPU 中比较重要的两个部件是运算器和控制器。

运算器里最重要的部件是 ALU，中文叫算术逻辑单元，用来进行算术和逻辑运算的。其它的 MQ,ACC 这些我们不用管了，是一些寄存器。

控制器中最重要的部件是 CU（控制单元），只要是分析指令，给出控制信号。IR（指令寄存器），存放当前需要执行的指令， PC 存放的指令的地址。

### 13、进制转化

二进制转十进制。 二进制的每个数去乘以 2 的相应次方,注意小数点后是乘以它的负相应次方。

2 进制 101.1 如何转化为 10 进制。1*2 平方+0*2+1*1+1*2 的负一次方 = 5.5

十进制整数转为二进制。对二取余然后反过来连接余数。

比如 29 的二进制是 11101

十进制小数转为二进制。方式是采用“乘 2 取整，顺序排列”法。

- 用 2 乘十进制小数，可以得到积，将积的整数部分取出
- 再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出
- 如此进行，直到积中的小数部分为零，或者达到所要求的精度为止

- 比如十进制 0.25 转为二进制
  - `0.25 * 2 = 0.5` 取出整数部分：0
  - `0.5 * 2 = 1.0` 取出整数部分 1
  - 所以 0.25 的二进制是 0.01

### 14、原码、反码和补码的介绍

- 原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。

- 正数的反码和其原码一样；负数的反码，符号位为 1，数值部分按原码取反。

  - 如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

- 正数的补码和其原码一样；负数的补码为其反码加 1。

  - [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；
  - [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

- 之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中
  我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。

### 15、位（bit）、字节（byte）、字符、编码之间的关系

- 位：数据存储的最小单位。每个二进制数字 0 或者 1 就是 1 个位；
- 字节：8 个位构成一个字节；即：1 byte (字节)= 8 bit(位)；1 KB = 1024 B(字节)；1M = 1024KB；
- 字符：汉字、字母、数字、符号等都是字符。一般 utf-8 编码下，一个汉字 字符 占用 3 个 字节；一般 gbk 编码下，一个汉字 字符 占用 2 个 字节；
- 字符集：字符组成的集合。Unicode 就是一个符号集（世界上所有符号的符号集）。
- 编码：规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。（其实际是对字符集中字符进行编码，即：每个字符用二进制在计算中表示存储）；通俗的说：编码就是按照规则对字符进行翻译成对应的二进制数，在计算器中运行存储，用户看的时候（比如浏览器），在用对应的编码解析出来用户能看懂的；最常用的 utf-8 就是 Unicode 字符集的实现方式之一。它使用 1-4 个字节表示一个符号，根据不同的符号而变化字节长度。

Unicode 和 UTF-8 之间的关系？

- Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。

- UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。

### 16、阻塞非阻塞 轮询

操作系统中对于 I/O 只有两种处理方式，即阻塞和非阻塞。

阻塞 I/O 即为调用之后需要等待完成所有操作后，调用才结束，这就造成了 CPU 一直在等待 I/O 结束，处理能力得不到充分利用。

非阻塞 I/O 在调用之后会立即返回，之后 CPU 可以去处理其他事务。但由于 I/O 并没有完成，立即返回的仅仅是调用的状态，为了获取最终结果，应用程序需要充分调用判断操作是否完成，即轮询。

常见的轮询技术

- read 这是最原始的一种，通过重复调用来读取最终结果，在得到结果之前，CPU 会一直消耗在等待上。
- select 在 read 基础上做了改进，通过对文件描述符上的事件状态来进行判断，当用户进程调用了 select，那么整个进程会被 block，而同时，kernel 会「监视」所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回，这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。select 和之后的 poll、epoll 也称为 I/O 多路复用。select 采用一个长度为 1024 的数组来存储状态，所以最多可以同时检查 1024 个文件描述符。
- poll 采用链表方式避免数组长度的限制，性能有所改善。
- epoll 这是 Linux 下效率最高的 I/O 事件通知机制，在进入轮询时如果没有检查到 I/O 事件，将会进行休眠，直到事件发生将它唤醒，不会浪费 CPU。
- kqueue 实现方式与 epoll 类似，仅在 BSD 系统下存在。

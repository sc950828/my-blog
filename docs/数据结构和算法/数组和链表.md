### 1、数组

数组是线性结构，在内存中是连续存储的。

在数组中，如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。所以增删慢。

但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))，所以数组的访问效率较高。查询快。

```js
const arr = [1, 2, 3, 4];
// 它是一个纯数字数组，那么对应的确实是连续内存。
const arr = ["haha", 1, { a: 1 }];
// 如果数组定义了不同类型的元素，它对应的就是一段非连续的内存。
// 此时，JS 数组不再具有数组的特征，其底层其实是由链表来实现的。
```

### 2、链表

链表和数组相似，它们都是有序的列表、都是线性结构。链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了联系。

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置。所以链表查询慢。

相对于数组来说，链表有一个明显的优点，就是添加和删除元素都不需要挪动多余的元素。所以增删快。在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

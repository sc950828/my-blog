## TCP 协议

位于传输层

TCP 协议 全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

## TCP 协议的特点

### 面向连接

面向连接，是指发送数据之前必须在两端建立连接，建立连接的方法就是 三次握手，这样能建立可靠的连接，为数据的可靠传输打下了基础

### 仅支持单播传输

每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式

### 面向字节流

TCP 不像 UDP 一样那样一个个报文独立传输，而是在不保留报文边界的情况下以字节流方式进行传输

### 可靠传输 排序 重传 接收确认

- 对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号，TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收
- 然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)，如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传

### 提供拥塞控制 流量控制

当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞

### TCP 提供全双工通信

TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据
当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）

## TCP 报文段首部结构

TCP 报文 (Segment)，包括首部和数据部分。TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的

1. 源端口和目的端口 Port

- 各占 2 个 字节，共 4 个字节。用来告知主机该报文段是来自哪里以及传送给哪个应用程序（应用程序绑定了端口）的。进行 TCP 通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。

2. 序号 Sequence Number

- 占 4 个字节。TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。例如 100 kb 的 HTML 文档数据，一共 102400 `(100 * 1024)`个字节，那么每一个字节就都有了编号，整个文档的编号的范围是 0 ~ 102399。序号字段值指的是本报文段所发送的数据的第一个字节的序号。那么 100 的 HTML 文档分割成四个等分之后，第一个 TCP 报文段包含的是第一个 25kb 的数据，0 ~ 25599 字节， 该报文的序号的值就是：0 第二个 TCP 报文段包含的是第二个 25kb 的数据，25600 ~ 51199 字节，该报文的序号的值就是：25600......根据 8 位 = 1 字节，那么 4 个字节可以表示的数值范围：[0, 2^32]，一共 2^32 (4294967296) 个序号。序号增加到最大值的时候，下一个序号又回到了 0.也就是说 TCP 协议可对 4GB 的数据进行编号，在一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络到达终点或者丢失了。

3. 确认号 Acknowledgemt Number

- 占 4 个字节。表示期望收到对方下一个报文段的序号值。TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。那么，确认报文，就会包含确认号。例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.

4. 数据偏移 Offset

- 占 0.5 个字节 (4 位)。这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP 报文段的数据起始处 距离 TCP 报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大度。

5. 保留 Reserved

- 占 0.75 个字节 (6 位)。保留为今后使用，但目前应置为 0。

6. 标志位 TCP Flags

- 标志位，一共有 6 个，分别占 1 位，共 6 位 。每一位的值只有 0 和 1，分别表达不同意思。

7. 窗口大小 Window Size

- 占 2 字节。该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。

8. 校验和 TCP Checksum

- 占 2 个字节。由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。

9. 紧急指针 Urgent Pointer

- 占 2 个字节。仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。

### TCP 的可靠运输机制

#### 停止等待协议

发送方给接收方发送消息，发送完之后会等待接收方的回答，接收方收到消息后会给发送方发送一个确认的消息。发送方收到接收方的消息后，如果还有消息即可再次发送。这样一来一回中间等待，我们就称作停止等待协议。

如果有发送的消息丢失、确认的消息丢失、确认消息很久才到等问题 我们使用超时重传机制来保证数据传输的可靠性。

超时重传采用超时定时器机制，每发送一个消息，都需要设置一个定时器。在规定时间内没有得到应答就重新发送数据。

停止等待协议对信道的利用效率不高。

#### 连续 ARQ 协议

批量发送消息，批量进行消息确认，是停止等待协议的升级版。

利用滑动窗口进行数据传输，每次传输一批数据，收到确认收到应答后，就滑动窗口，传输下批数据。

滑动窗口的滑动以字节为单位

确认机制采用累记确认，收到某个消息的确认后，该消息前的数据就默认已发送成功。

采用选择重传进行重传，效率大大提升。

### TCP 的流量控制机制

TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。流量控制就是让发送方发送速率不要太快。

#### TCP 利用滑动窗口实现流量控制。

TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。

当滑动窗口为 0 时，发送方一般不能再发送数据报。然后启动坚持定时器进行轮询查询，每隔一段时间发送一个窗口探测报文。

当滑动窗口为 0 时，发送方一般不能再发送数据报。但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### TCP 的拥塞控制机制

TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。

TCP 的拥塞控制主要使用了慢启动和拥塞避免

慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达 到一个阈值的时候就进入拥塞避免算法。

拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。

### http 三次握手 四次挥手都干了些啥？

    四次挥手
      客户端发送带fin标志的包 fin=m，进入FIN-WAIT1状态
      服务端收到fin包然后再发送带ack标志的包 ack=m+1，进入CLOSE_WAIT状态。服务端仍然可以发送数据。
      服务端发送带fin标志的包 fin=n，服务端进入LAST-ACK状态
      客户端收到服务端发送的的fin包，发送ack包 ack=n+1。客户端进入TIME-WAIT状态。该状态会持续 2MSL。
      若2MSL时间段内没有 服务端的重发请求的话，就进入 CLOSED 状态，当服务端收到确认应答后，也便进入 CLOSED 状态

## TCP 三次握手

### 三次握手

1. 发送方发送带 SYN=1,seq=x 标志。 发送方进入 SYNC-SENT 状态
2. 接收方收到包后发送带 SYN=1,ACK=1,seq=y,ack=x+1 标志。 接收方进入 SYNC-RECEIVED 状态
3. 客户端收到服务端的包然后再发送带 ACK=1,seq=x+1,ack=y+1 标志。 发送方 进入 ESTABLISHED 状态，接收方 进入 ESTABLISHED 状态

### 为什么是三次握手？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

当客户端发出第一个连接请求报文段时并没有丢失，而是在某个网络节点出现了长时间的滞留，以至于延误了连接请求在某个时间之后才到达服务器。这应该是一个早已失效的报文段。但是服务器在收到此失效的连接请求报文段后，以为是客户端的一个新请求，于是就向客户端发出了确认报文段，同意建立连接，然而客户端状态早已不是 SYNC-SENT 状态，所以并不会传输数据。假设不采用三次握手，那么只要服务器发出确认后，新的连接就可以建立了。但是由于客户端没有发出建立连接的请求，因此不会管服务器的确认，也不会向服务器发送数据，但服务器却以为新的运输连接已经建立，一直在等待，所以，服务器的资源就白白浪费掉了。

## TCP 四次挥手

### 四次挥手

1. 发送方发送带 FIN=1,seq=u 标志，进入 FIN-WAIT1 状态
2. 接收方收到 FIN 包然后再发送带 ACK=1,seq=v,ack=u+1 标志，进入 CLOSE_WAIT 状态。接收方仍然可以发送数据。
3. 接收方发送带 FIN=1,ACK=1,seq=w,ack=v+1 标志，服务端进入 LAST-ACK 状态.
4. 发送方收到接收方发送的的 FIN 包，发送 ACK=1,seq=u+1,ack=w+1 标志。发送方进入 TIME-WAIT 状态。该状态会持续 2MSL（最常报文段寿命），会启用等待计时器。
5. 当接收方收到确认应答后，进入 CLOSED 状态。发送方若 2MSL 时间段内没有收到接收方的重发请求的话，才进入 CLOSED 状态。

### 为何客户端最后还等待 2MSL

为了保证最后发送的 ack 包能被接收方接收到，所以发送方要等待两个最长报文段寿命的时间，以便于接收方没有收到请求之后重新发送请求。发送方等待 2MSL 后依然没有收到回复，则证明 接收方 端已正常关闭，那好，发送方 也可以关闭连接了。

### 为什么是四次挥手？

因为服务端第三次挥手的时候没有立即进入 CLOSE 状态，而是进入了 CLOSE_WAIT 状态。直到等到发送方第四次挥手消息到达才会进入 CLOSE 状态。

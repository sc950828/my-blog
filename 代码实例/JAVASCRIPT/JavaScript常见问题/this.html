<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>this问题</title>
    <style>
      .father {
        width: 200px;
        height: 200px;
        background-color: aquamarine;
      }
      .child {
        width: 100px;
        height: 100px;
        background-color: beige;
      }
    </style>
  </head>
  <body>
    <div class="father">
      father
      <div class="child">child</div>
    </div>
    <button onclick="console.log(this)">作为一个内联事件处理函数中的this</button>
    <button onclick="(function(){console.log(this)})()">作为一个内联事件处理函数中当代码被包括在函数内部执行时this</button>
    <button onclick="(function(){'use strict';console.log(this)})()">作为一个内联事件处理函数中当代码被包括在函数内部执行时严格模式this</button>
    <script>
      // 全局环境下，this始终指向全局对象（window），无论是否严格模式；
      // 在浏览器中，全局对象为 window 对象：
      console.log(this === window); // true
      this.a = 37;
      console.log(window.a); // 37

      // 普通函数
      // 普通函数内部的this分两种情况，严格模式和非严格模式。
      // 非严格模式下，this 默认指向全局对象window。
      // 严格模式下，this指向undefined。
      function f1() {
        console.log("普通函数非严格模式下，this 默认指向全局对象window", this);
        return this;
      }
      console.log(f1() === window); // true
      function f2() {
        "use strict"; // 这里是严格模式
        console.log("普通函数严格模式下，this 默认指向undefined", this);
        return this;
      }
      console.log(f2() === undefined); // true

      // 函数作为对象的方法
      // 当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。
      // 多层嵌套的对象，内部方法的this指向离被调用函数最近的对象
      //方式1
      var o = {
        prop: 37,
        f: function() {
          return this.prop;
        }
      };
      //当 o.f()被调用时，函数内的this将绑定到o对象。
      console.log(o.f()); // logs 37
      //方式2
      var o = { prop: 37 };
      function independent() {
        return this.prop;
      }
      //函数f作为o的成员方法调用
      o.f = independent;
      console.log(o.f()); // logs 37
      //方式3
      //this 的绑定只受最靠近的成员引用的影响
      o = { prop: 37, b: { g: independent, prop: 42 } };
      console.log(o.b.g()); // 42

      // 构造函数中的this
      // 当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。
      // 构造器返回的默认值是this所指的那个对象，也可以手动返回其他的对象。
      function C() {
        this.a = 37;
      }

      var o = new C();
      console.log(o.a); // logs 37

      function C2() {
        this.a = 37;
        return { a: 38 }; //手动设置返回{a:38}对象
      }

      o = new C2();
      console.log(o.a); // logs 38

      // setTimeOut this
      // 对于延时函数内部的回调函数的this指向全局对象window；
      // 可以通过bind()方法改变内部函数this指向。
      setTimeout(function() {
        console.log("setTimeout this=", this);
      }, 1000);
      setTimeout(
        function() {
          console.log("setTimeout bind {name: 'randy'} this=", this);
        }.bind({ name: "randy" }),
        1000
      );

      // 在DOM事件中 this总是与currentTarget相等
      document
        .getElementsByClassName("father")[0]
        .addEventListener("click", function(e) {
          // currentTarget是绑定事件的元素
          // target是触发事件的元素
          console.log(e.target === this);
          console.log(e.currentTarget === this); // 总是 true
        });
      // 作为一个内联事件处理函数
      // 当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素；
      // 当代码被包括在函数内部执行时，其this指向等同于 普通函数直接调用的情况，即在非严格模式指向全局对象window，在严格模式指向undefined
    </script>
  </body>
</html>

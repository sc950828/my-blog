<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>继承</title>
  </head>
  <body>
    <script>
      // 原型继承
      // 能继承父类原型上的方法和属性 一个实例修改所有实例都会发生变化 
      function Person(name, age) {
        // console.log(this);
        this.name = name;
        this.age = age;
        this.colors = ["red"];

        this.sayName = function() {
          console.log(this.name);
        };
      }
      let Fa = {
        say: function() {
          //console.log(this); // 对象调用就指向该对象
          console.log(this.name + ":" + this.age);
        }
      };
      Person.prototype = Fa;

      const p1 = new Person("randy", 24);
      console.log(p1);
      p1.sayName();
      // 修改父类方法 只会影响自己
      p1.sayName = function() {
        console.log("randy sayName");
      };
      p1.sayName();
      p1.say();
      // 修改原型上的方法 所有的实例都会变
      p1.__proto__.say = function() {
        console.log("randy say");
      };
      p1.say(); //randy say
      // 修改父类属性 所有的实例都会变
      p1.colors.push("yellow");
      console.log(p1.colors);
      console.log("p1 instanceof Person", p1 instanceof Person);

      const p2 = new Person("demi", 25);
      console.log(p2);
      p2.sayName(); // demi
      p2.say(); //randy say
      console.log(p1.colors);
      console.log("p2 instanceof Person", p2 instanceof Person);

      // 构造继承
      // 能传参给父构造器 不能使用父原型上的方法 不是父类的实例
      function Person1(name, age) {
        this.name = name;
        this.age = age;
        this.colors = ["red"]; 
        this.say = function () {
          console.log(this.name);
        }
      }
      Person1.prototype.hello = function() {
        console.log('Person1 hello');
      }
      function People1(name, age) {
        Person1.call(this, name, age);
        this.say1 = function () {
          console.log(this.name);
        }
      }
      People1.prototype.hello1 = function() {
        console.log('People1 hello');
      }
      const pe1 = new People1("randy", 24);
      console.log("pe1: ", pe1);
      // 不是父类的实例
      console.log(pe1 instanceof Person1); // false
      console.log(pe1 instanceof People1);
      pe1.say()
      pe1.say1()
      pe1.hello1()
      // pe1.hello() //父类的原型链上的方法获取不到
      pe1.colors.push("black")
      console.log(pe1.colors);
      let pe2 = new People1('demi', 25)
      // 不会修改其他实例的属性
      console.log(pe2.colors);

      // 组合继承
      function Person2 (name, age) {
        this.name = name;
        this.age = age;
        this.colors = ["red"]; 
        this.say = function () {
          console.log(this.name);
        }
      }
      Person2.prototype.hello = function() {
        console.log('Person2 hello');
      }
      function People2(name, age) {
        Person2.call(this, name, age);
        this.say1 = function () {
          console.log(this.name);
        }
      }
      // 调用了两次父构造器
      People2.prototype = new Person2()
      People2.prototype.constructor = Person2

      let peo1 = new People2('randy', 24)
      console.log(peo1);
      peo1.say()
      peo1.say1()
      peo1.hello()//能获取到父类原型链上的方法
    </script>
  </body>
</html>

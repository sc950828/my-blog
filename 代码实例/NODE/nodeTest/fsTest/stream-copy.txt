Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。Node.js感悟

一、前言

    很久以前就对node.js十分的好奇和感兴趣，因为种种原因没能去深入的认识了解和学习掌握这门技术，最近正好要做一些项目，其中就用到了node.js中的一些东西，所以借着使用的时间来对node.js进行一些剖析，每一种语言都有自己的理念和设计初衷，但是万变不离其宗，最终还是要归结到编译和执行，对于一门新的语言，我们不要急着去记忆语法，最好的方式就是通过问题的形式去不断的积累经验，自然而然的那些语法，特殊思想就渐渐地熟能生巧了，万事开头难，任何东西到了一定的程度之后都是殊途同归的，本人也学习了很多语言，解释性语言和执行性语言遇到的也比较多，对于node.js在这里就将我自己的学习过程和经验记录下来，一方面是为了以后的查阅和学习，另一方面是为广大的IT界网友的知识库中增砖添瓦，好了，闲言休谈，直入主题！

二、node.js的性质、优缺点和适用范围

    Node.js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。但Node似乎有点不同：Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。Node.js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。

    单线程：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

    非阻塞I/O：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（阻塞I/O），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

    事件驱动：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的），底层代码中，近半数都用于事件队列、回调函数队列的构建。

    优缺点：因为单线程，在处理大规模并发的任务中还是会显得力不从心的，比如在CPU密集型事务中就会遇到瓶颈，另外就是node.js是没有web容器的，代码直接没有根目录的说法，在一定程度上为程序员增加了代码量，但也提高了灵活性，为高级路由带来了极大的方便，在node.js中回调函数会有很深的层次，为代码的阅读多多少少造成了一定的障碍。善于处理异步事件（callback），处理同步事务中需要额外的负担。

    适用范围：当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。比如：用户表单收集、考试系统、聊天室、图文直播、提供JSON的API（为前台Angular使用）。